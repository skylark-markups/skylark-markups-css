{"version":3,"sources":["primitives/beautify-css.js"],"names":["define","css_beautify","source_text","options","next","ch","charAt","pos","peek","skipWhitespace","prev_pos","eatWhitespace","result","eatString","endChars","start","indexOf","substring","peekString","endChar","str","whiteRe","test","eatComment","singleLine","lookBack","length","toLowerCase","foundNestedPseudoClass","i","indent","indentLevel","basebaseIndentString","singleIndent","outdent","slice","indentSize","indent_size","indentCharacter","indent_char","selectorSeparatorNewline","undefined","selector_separator_newline","end_with_newline","parseInt","match","Array","join","nestedLevel","print","singleSpace","output","push","newLine","_lastCharWhitespace","keepWhitespace","trim","pop","insideRule","enteringConditionalGroup","top_ch","last_top_ch","whitespace","isAfterSpace","isAfterNewline","header","variableOrRule","replace","NESTED_AT_RULE","CONDITIONAL_GROUP_RULE","sweetCode","@page","@font-face","@keyframes","@media","@supports","@document"],"mappings":"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","file":"../../primitives/beautify-css.js","sourcesContent":["/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n CSS Beautifier\n---------------\n\n    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)\n\n    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>\n        http://jsbeautifier.org/\n\n    Usage:\n        css_beautify(source_text);\n        css_beautify(source_text, options);\n\n    The options are (default in brackets):\n        indent_size (4)                   — indentation size,\n        indent_char (space)               — character to indent with,\n        selector_separator_newline (true) - separate selectors with newline or\n                                            not (e.g. \"a,\\nbr\" or \"a, br\")\n        end_with_newline (false)          - end with a newline\n\n    e.g\n\n    css_beautify(css_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t',\n      'selector_separator': ' ',\n      'end_with_newline': false,\n    });\n*/\n\n// http://www.w3.org/TR/CSS21/syndata.html#tokenization\n// http://www.w3.org/TR/css3-syntax/\n\ndefine([],function() {\n    function css_beautify(source_text, options) {\n        options = options || {};\n        var indentSize = options.indent_size || 4;\n        var indentCharacter = options.indent_char || ' ';\n        var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;\n        var end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;\n\n        // compatibility\n        if (typeof indentSize === \"string\") {\n            indentSize = parseInt(indentSize, 10);\n        }\n\n\n        // tokenizer\n        var whiteRe = /^\\s+$/;\n        var wordRe = /[\\w$\\-_]/;\n\n        var pos = -1,\n            ch;\n\n        function next() {\n            ch = source_text.charAt(++pos);\n            return ch || '';\n        }\n\n        function peek(skipWhitespace) {\n            var prev_pos = pos;\n            if (skipWhitespace) {\n                eatWhitespace();\n            }\n            result = source_text.charAt(pos + 1) || '';\n            pos = prev_pos - 1;\n            next();\n            return result;\n        }\n\n        function eatString(endChars) {\n            var start = pos;\n            while (next()) {\n                if (ch === \"\\\\\") {\n                    next();\n                } else if (endChars.indexOf(ch) !== -1) {\n                    break;\n                } else if (ch === \"\\n\") {\n                    break;\n                }\n            }\n            return source_text.substring(start, pos + 1);\n        }\n\n        function peekString(endChar) {\n            var prev_pos = pos;\n            var str = eatString(endChar);\n            pos = prev_pos - 1;\n            next();\n            return str;\n        }\n\n        function eatWhitespace() {\n            var result = '';\n            while (whiteRe.test(peek())) {\n                next()\n                result += ch;\n            }\n            return result;\n        }\n\n        function skipWhitespace() {\n            var result = '';\n            if (ch && whiteRe.test(ch)) {\n                result = ch;\n            }\n            while (whiteRe.test(next())) {\n                result += ch\n            }\n            return result;\n        }\n\n        function eatComment(singleLine) {\n            var start = pos;\n            var singleLine = peek() === \"/\";\n            next();\n            while (next()) {\n                if (!singleLine && ch === \"*\" && peek() === \"/\") {\n                    next();\n                    break;\n                } else if (singleLine && ch === \"\\n\") {\n                    return source_text.substring(start, pos);\n                }\n            }\n\n            return source_text.substring(start, pos) + ch;\n        }\n\n\n        function lookBack(str) {\n            return source_text.substring(pos - str.length, pos).toLowerCase() ===\n                str;\n        }\n\n        // Nested pseudo-class if we are insideRule\n        // and the next special character found opens\n        // a new block\n        function foundNestedPseudoClass() {\n            for (var i = pos + 1; i < source_text.length; i++){\n                var ch = source_text.charAt(i);\n                if (ch === \"{\"){\n                    return true;\n                } else if (ch === \";\" || ch === \"}\" || ch === \")\") {\n                    return false;\n                }\n            }\n            return false;\n        }\n\n        // printer\n        var basebaseIndentString = source_text.match(/^[\\t ]*/)[0];\n        var singleIndent = new Array(indentSize + 1).join(indentCharacter);\n        var indentLevel = 0;\n        var nestedLevel = 0;\n\n        function indent() {\n            indentLevel++;\n            basebaseIndentString += singleIndent;\n        }\n\n        function outdent() {\n            indentLevel--;\n            basebaseIndentString = basebaseIndentString.slice(0, -indentSize);\n        }\n\n        var print = {};\n        print[\"{\"] = function(ch) {\n            print.singleSpace();\n            output.push(ch);\n            print.newLine();\n        };\n        print[\"}\"] = function(ch) {\n            print.newLine();\n            output.push(ch);\n            print.newLine();\n        };\n\n        print._lastCharWhitespace = function() {\n            return whiteRe.test(output[output.length - 1]);\n        };\n\n        print.newLine = function(keepWhitespace) {\n            if (!keepWhitespace) {\n                print.trim();\n            }\n\n            if (output.length) {\n                output.push('\\n');\n            }\n            if (basebaseIndentString) {\n                output.push(basebaseIndentString);\n            }\n        };\n        print.singleSpace = function() {\n            if (output.length && !print._lastCharWhitespace()) {\n                output.push(' ');\n            }\n        };\n\n        print.trim = function() {\n            while (print._lastCharWhitespace()) {\n                output.pop();\n            }\n        };\n\n\n        var output = [];\n        if (basebaseIndentString) {\n            output.push(basebaseIndentString);\n        }\n        /*_____________________--------------------_____________________*/\n\n        var insideRule = false;\n        var enteringConditionalGroup = false;\n        var top_ch = '';\n        var last_top_ch = '';\n\n        while (true) {\n            var whitespace = skipWhitespace();\n            var isAfterSpace = whitespace !== '';\n            var isAfterNewline = whitespace.indexOf('\\n') !== -1;\n            var last_top_ch = top_ch;\n            var top_ch = ch;\n\n            if (!ch) {\n                break;\n            } else if (ch === '/' && peek() === '*') { /* css comment */\n                var header = lookBack(\"\");\n                print.newLine();\n                output.push(eatComment());\n                print.newLine();\n                if (header) {\n                    print.newLine(true);\n                }\n            } else if (ch === '/' && peek() === '/') { // single line comment\n                if (!isAfterNewline && last_top_ch !== '{') {\n                    print.trim();\n                }\n                print.singleSpace();\n                output.push(eatComment());\n                print.newLine();\n            } else if (ch === '@') {\n                // pass along the space we found as a separate item\n                if (isAfterSpace) {\n                    print.singleSpace();\n                }\n                output.push(ch);\n\n                // strip trailing space, if present, for hash property checks\n                var variableOrRule = peekString(\": ,;{}()[]/='\\\"\").replace(/\\s$/, '');\n\n                // might be a nesting at-rule\n                if (variableOrRule in css_beautify.NESTED_AT_RULE) {\n                    nestedLevel += 1;\n                    if (variableOrRule in css_beautify.CONDITIONAL_GROUP_RULE) {\n                        enteringConditionalGroup = true;\n                    }\n                } else if (': '.indexOf(variableOrRule[variableOrRule.length -1]) >= 0) {\n                    //we have a variable, add it and insert one space before continuing\n                    next();\n                    variableOrRule = eatString(\": \").replace(/\\s$/, '');\n                    output.push(variableOrRule);\n                    print.singleSpace();\n                }\n            } else if (ch === '{') {\n                if (peek(true) === '}') {\n                    eatWhitespace();\n                    next();\n                    print.singleSpace();\n                    output.push(\"{}\");\n                } else {\n                    indent();\n                    print[\"{\"](ch);\n                    // when entering conditional groups, only rulesets are allowed\n                    if (enteringConditionalGroup) {\n                        enteringConditionalGroup = false;\n                        insideRule = (indentLevel > nestedLevel);\n                    } else {\n                        // otherwise, declarations are also allowed\n                        insideRule = (indentLevel >= nestedLevel);\n                    }\n                }\n            } else if (ch === '}') {\n                outdent();\n                print[\"}\"](ch);\n                insideRule = false;\n                if (nestedLevel) {\n                    nestedLevel--;\n                }\n            } else if (ch === \":\") {\n                eatWhitespace();\n                if ((insideRule || enteringConditionalGroup) &&\n                        !(lookBack(\"&\") || foundNestedPseudoClass())) {\n                    // 'property: value' delimiter\n                    // which could be in a conditional group query\n                    output.push(':');\n                    print.singleSpace();\n                } else {\n                    // sass/less parent reference don't use a space\n                    // sass nested pseudo-class don't use a space\n                    if (peek() === \":\") {\n                        // pseudo-element\n                        next();\n                        output.push(\"::\");\n                    } else {\n                        // pseudo-class\n                        output.push(':');\n                    }\n                }\n            } else if (ch === '\"' || ch === '\\'') {\n                if (isAfterSpace) {\n                    print.singleSpace();\n                }\n                output.push(eatString(ch));\n            } else if (ch === ';') {\n                output.push(ch);\n                print.newLine();\n            } else if (ch === '(') { // may be a url\n                if (lookBack(\"url\")) {\n                    output.push(ch);\n                    eatWhitespace();\n                    if (next()) {\n                        if (ch !== ')' && ch !== '\"' && ch !== '\\'') {\n                            output.push(eatString(')'));\n                        } else {\n                            pos--;\n                        }\n                    }\n                } else {\n                    if (isAfterSpace) {\n                        print.singleSpace();\n                    }\n                    output.push(ch);\n                    eatWhitespace();\n                }\n            } else if (ch === ')') {\n                output.push(ch);\n            } else if (ch === ',') {\n                output.push(ch);\n                eatWhitespace();\n                if (!insideRule && selectorSeparatorNewline) {\n                    print.newLine();\n                } else {\n                    print.singleSpace();\n                }\n            } else if (ch === ']') {\n                output.push(ch);\n            } else if (ch === '[') {\n                if (isAfterSpace) {\n                    print.singleSpace();\n                }\n                output.push(ch);\n            } else if (ch === '=') { // no whitespace before or after\n                eatWhitespace();\n                output.push(ch);\n            } else {\n                if (isAfterSpace) {\n                    print.singleSpace();\n                }\n\n                output.push(ch);\n            }\n        }\n\n\n        var sweetCode = output.join('').replace(/[\\r\\n\\t ]+$/, '');\n\n        // establish end_with_newline\n        if (end_with_newline) {\n            sweetCode += \"\\n\";\n        }\n\n        return sweetCode;\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n    css_beautify.NESTED_AT_RULE = {\n        \"@page\": true,\n        \"@font-face\": true,\n        \"@keyframes\": true,\n        // also in CONDITIONAL_GROUP_RULE below\n        \"@media\": true,\n        \"@supports\": true,\n        \"@document\": true\n    };\n    css_beautify.CONDITIONAL_GROUP_RULE = {\n        \"@media\": true,\n        \"@supports\": true,\n        \"@document\": true\n    };\n\n    return {\n        css_beautify: css_beautify\n    };\n});\n"]}