{"version":3,"sources":["primitives/parser-lib.js"],"names":["define","EventTarget","this","_listeners","StringReader","text","_input","replace","_line","_col","_cursor","SyntaxError","message","line","col","SyntaxUnit","type","TokenStreamBase","input","tokenData","_reader","toString","_token","_tokenData","_lt","_ltIndex","_ltIndexCache","Combinator","call","Parser","COMBINATOR_TYPE","test","MediaFeature","name","value","startLine","startCol","MEDIA_FEATURE_TYPE","MediaQuery","modifier","mediaType","features","length","join","MEDIA_QUERY_TYPE","options","_tokenStream","PropertyName","hack","PROPERTY_NAME_TYPE","PropertyValue","parts","PROPERTY_VALUE_TYPE","PropertyValueIterator","_i","_parts","_marks","PropertyValuePart","PROPERTY_VALUE_PART_TYPE","temp","RegExp","$1","units","$2","toLowerCase","red","parseInt","charAt","green","blue","substring","$3","alpha","$4","hue","saturation","lightness","uri","eval","Colors","Selector","SELECTOR_TYPE","specificity","Specificity","calculate","SelectorPart","elementName","modifiers","SELECTOR_PART_TYPE","SelectorSubPart","SELECTOR_SUB_PART_TYPE","args","a","b","c","d","isHexDigit","h","isDigit","isWhitespace","isNewLine","nl","isNameStart","isNameChar","isIdentStart","mix","receiver","supplier","prop","hasOwnProperty","TokenStream","Tokens","ValidationError","parserlib","prototype","constructor","addListener","listener","push","fire","event","target","Error","listeners","concat","i","len","removeListener","splice","getCol","getLine","eof","peek","count","read","mark","_bookmark","cursor","reset","readTo","pattern","buffer","lastIndexOf","readWhile","filter","readMatch","matcher","source","indexOf","readCount","lastMatch","fromToken","token","valueOf","createTokenData","tokens","nameMap","typeMap","UNKNOWN","unshift","tt","match","tokenTypes","channel","Array","get","unget","mustMatch","apply","arguments","LT","advance","LA","info","tokenInfo","undefined","_getToken","hide","shift","index","total","tokenName","tokenType","pop","util","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","activeBorder","activecaption","appworkspace","background","buttonface","buttonhighlight","buttonshadow","buttontext","captiontext","graytext","highlight","highlighttext","inactiveborder","inactivecaption","inactivecaptiontext","infobackground","infotext","menu","menutext","scrollbar","threeddarkshadow","threedface","threedhighlight","threedlightshadow","threedshadow","window","windowframe","windowtext","DEFAULT_TYPE","proto","additions","_stylesheet","tokenStream","_charset","_skipCruft","IMPORT_SYM","_import","NAMESPACE_SYM","_namespace","EOF","MEDIA_SYM","_media","PAGE_SYM","_page","FONT_FACE_SYM","_font_face","KEYFRAMES_SYM","_keyframes","VIEWPORT_SYM","_viewport","UNKNOWN_SYM","strict","error","LBRACE","RBRACE","S","_readWhitespace","_ruleset","CHARSET_SYM","_unexpectedToken","ex","emit","charset","STRING","SEMICOLON","importToken","mediaList","URI","_media_query_list","media","prefix","IDENT","LPAREN","_media_query","COMMA","ident","expressions","_media_type","_media_expression","_media_feature","feature","expression","COLON","_expression","RPAREN","identifier","pseudoPage","_pseudo_page","id","pseudo","_readDeclarations","_margin","marginSym","_margin_sym","margin","TOPLEFTCORNER_SYM","TOPLEFT_SYM","TOPCENTER_SYM","TOPRIGHT_SYM","TOPRIGHTCORNER_SYM","BOTTOMLEFTCORNER_SYM","BOTTOMLEFT_SYM","BOTTOMCENTER_SYM","BOTTOMRIGHT_SYM","BOTTOMRIGHTCORNER_SYM","LEFTTOP_SYM","LEFTMIDDLE_SYM","LEFTBOTTOM_SYM","RIGHTTOP_SYM","RIGHTMIDDLE_SYM","RIGHTBOTTOM_SYM","_operator","inFunction","SLASH","PLUS","STAR","MINUS","_combinator","GREATER","TILDE","_unary_operator","_property","tokenValue","starHack","underscoreHack","selectors","_selectors_group","selector","_selector","nextSelector","combinator","ws","_simple_selector_sequence","selectorText","components","HASH","_class","_attrib","_pseudo","_negation","component","_type_selector","_universal","ns","_namespace_prefix","_element_name","DOT","PIPE","LBRACKET","PREFIXMATCH","SUFFIXMATCH","SUBSTRINGMATCH","EQUALS","INCLUDES","DASHMATCH","RBRACKET","colons","FUNCTION","_functional_pseudo","DIMENSION","NUMBER","LENGTH","FREQ","ANGLE","TIME","RESOLUTION","arg","subpart","NOT","_negation_arg","part","_declaration","property","expr","prio","invalid","propertyName","_expr","_prio","_validateProperty","important","result","IMPORTANT_SYM","values","operator","_term","unary","IE_FUNCTION","ieFilters","_ie_function","PERCENTAGE","UNICODE_RANGE","_hexcolor","_function","lt","functionText","color","_keyframe_name","_keyframe_rule","keyList","_key_list","keys","_key","CDO","CDC","checkStart","readMargins","_verifyEnd","Validation","validate","parse","parseStyleSheet","parseMediaQuery","parsePropertyValue","parseRule","parseSelector","parseStyleAttribute","Properties","alignment-adjust","alignment-baseline","animation","animation-delay","multi","comma","animation-direction","animation-duration","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","-moz-animation-delay","-moz-animation-direction","-moz-animation-duration","-moz-animation-iteration-count","-moz-animation-name","-moz-animation-play-state","-ms-animation-delay","-ms-animation-direction","-ms-animation-duration","-ms-animation-iteration-count","-ms-animation-name","-ms-animation-play-state","-webkit-animation-delay","-webkit-animation-direction","-webkit-animation-duration","-webkit-animation-iteration-count","-webkit-animation-name","-webkit-animation-play-state","-o-animation-delay","-o-animation-direction","-o-animation-duration","-o-animation-iteration-count","-o-animation-name","-o-animation-play-state","appearance","azimuth","simple","direction","behind","valid","ValidationTypes","isAny","hasNext","next","backface-visibility","background-attachment","background-clip","background-color","background-image","background-origin","background-position","background-repeat","background-size","baseline-shift","behavior","binding","bleed","bookmark-label","bookmark-level","bookmark-state","bookmark-target","border","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","max","border-image","border-image-outset","border-image-repeat","border-image-slice","numeric","fill","border-image-source","border-image-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","slash","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","bottom","box-align","box-decoration-break","box-direction","box-flex","box-flex-group","box-lines","box-ordinal-group","box-orient","box-pack","box-shadow","multiProperty","Infinity","box-sizing","break-after","break-before","break-inside","caption-side","clear","clip","color-profile","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columns","content","counter-increment","counter-reset","crop","cue","cue-after","cue-before","display","dominant-baseline","drop-initial-after-adjust","drop-initial-after-align","drop-initial-before-adjust","drop-initial-before-align","drop-initial-size","drop-initial-value","elevation","empty-cells","fit","fit-position","float","float-offset","font","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","grid-cell-stacking","grid-column","grid-columns","grid-column-align","grid-column-sizing","grid-column-span","grid-flow","grid-layer","grid-row","grid-rows","grid-row-align","grid-row-span","grid-row-sizing","hanging-punctuation","height","hyphenate-after","hyphenate-before","hyphenate-character","hyphenate-lines","hyphenate-resource","hyphens","icon","image-orientation","image-rendering","image-resolution","inline-box-align","left","letter-spacing","line-height","line-break","line-stacking","line-stacking-ruby","line-stacking-shift","line-stacking-strategy","list-style","list-style-image","list-style-position","list-style-type","margin-bottom","margin-left","margin-right","margin-top","mark-after","mark-before","marks","marquee-direction","marquee-play-count","marquee-speed","marquee-style","max-height","max-width","min-height","min-width","move-to","nav-down","nav-index","nav-left","nav-right","nav-up","opacity","orphans","outline","outline-color","outline-offset","outline-style","outline-width","overflow","overflow-style","overflow-x","overflow-y","padding","padding-bottom","padding-left","padding-right","padding-top","page","page-break-after","page-break-before","page-break-inside","page-policy","pause","pause-after","pause-before","perspective","perspective-origin","phonemes","pitch","pitch-range","play-during","pointer-events","position","presentation-level","punctuation-trim","quotes","rendering-intent","resize","rest","rest-after","rest-before","richness","right","rotation","rotation-point","ruby-align","ruby-overhang","ruby-position","ruby-span","size","speak","speak-header","speak-numeral","speak-punctuation","speech-rate","src","stress","string-set","table-layout","tab-size","target-name","target-new","target-position","text-align","text-align-last","text-decoration","text-emphasis","text-height","text-indent","text-justify","text-outline","text-overflow","text-rendering","text-shadow","text-transform","text-wrap","top","transform","transform-origin","transform-style","transition","transition-delay","transition-duration","transition-property","transition-timing-function","unicode-bidi","user-modify","user-select","vertical-align","visibility","voice-balance","voice-duration","voice-family","voice-pitch","voice-pitch-range","voice-rate","voice-stress","voice-volume","volume","white-space","white-space-collapse","widows","width","word-break","word-spacing","word-wrap","z-index","zoom","isFirst","previous","restore","Pseudos",":first-letter",":first-line",":before",":after","ELEMENT","CLASS","isElement","compare","other","comps","updateValues","j","num","nonascii","reader","commentToken","charToken","comparisonToken","stringToken","hashToken","numberToken","htmlCommentEndToken","identOrFunctionToken","importantToken","atRuleToken","notToken","htmlCommentStartToken","unicodeRangeToken","whitespaceToken","createToken","endLine","endCol","first","rule","CHAR","readName","comment","readComment","COMMENT","comparison","readURI","readWhitespace","readNumber","delim","string","prev","INVALID","readUnicodeRangePart","allowQuestionMark","whitespace","number","hasDot","readString","inner","readURL","url","readEscape","cssEscape","state","spec","groupProperty","singleProperty","types","partial","typeCount","split","groups","isAnyOfGroup","isLiteral","literals","found","isSimple","isComplex","complex","isType","<absolute-size>","<attachment>","<attr>","<bg-image>","<gradient>","<box>","<content>","<relative-size>","<ident>","<length>","<color>","<number>","<integer>","<line>","<angle>","<uri>","<image>","<percentage>","<border-width>","<border-style>","<margin-width>","<padding-width>","<shape>","<time>","<bg-position>","xDir","yDir","<bg-size>","<repeat-style>","<shadow>","inset","<x-one-radius>","css"],"mappings":"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","file":"../../primitives/parser-lib.js","sourcesContent":["   /*!\r\n    Parser-Lib\r\n    Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.\r\n\r\n    Permission is hereby granted, free of charge, to any person obtaining a copy\r\n    of this software and associated documentation files (the \"Software\"), to deal\r\n    in the Software without restriction, including without limitation the rights\r\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n    copies of the Software, and to permit persons to whom the Software is\r\n    furnished to do so, subject to the following conditions:\r\n\r\n    The above copyright notice and this permission notice shall be included in\r\n    all copies or substantial portions of the Software.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n    THE SOFTWARE.\r\n\r\n    */\r\n    /* Version v0.2.3, Build time: 19-June-2013 11:16:15 */\r\n\r\ndefine([],function(){\r\n    var parserlib = {};\r\n\r\n\r\n    /**\r\n     * A generic base to inherit from for any object\r\n     * that needs event handling.\r\n     * @class EventTarget\r\n     * @constructor\r\n     */\r\n    function EventTarget(){\r\n\r\n        /**\r\n         * The array of listeners for various events.\r\n         * @type Object\r\n         * @property _listeners\r\n         * @private\r\n         */\r\n        this._listeners = {};\r\n    }\r\n\r\n    EventTarget.prototype = {\r\n\r\n        //restore constructor\r\n        constructor: EventTarget,\r\n\r\n        /**\r\n         * Adds a listener for a given event type.\r\n         * @param {String} type The type of event to add a listener for.\r\n         * @param {Function} listener The function to call when the event occurs.\r\n         * @return {void}\r\n         * @method addListener\r\n         */\r\n        addListener: function(type, listener){\r\n            if (!this._listeners[type]){\r\n                this._listeners[type] = [];\r\n            }\r\n\r\n            this._listeners[type].push(listener);\r\n        },\r\n\r\n        /**\r\n         * Fires an event based on the passed-in object.\r\n         * @param {Object|String} event An object with at least a 'type' attribute\r\n         *      or a string indicating the event name.\r\n         * @return {void}\r\n         * @method fire\r\n         */\r\n        fire: function(event){\r\n            if (typeof event == \"string\"){\r\n                event = { type: event };\r\n            }\r\n            if (typeof event.target != \"undefined\"){\r\n                event.target = this;\r\n            }\r\n\r\n            if (typeof event.type == \"undefined\"){\r\n                throw new Error(\"Event object missing 'type' property.\");\r\n            }\r\n\r\n            if (this._listeners[event.type]){\r\n\r\n                var listeners = this._listeners[event.type].concat();\r\n                for (var i=0, len=listeners.length; i < len; i++){\r\n                    listeners[i].call(this, event);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Removes a listener for a given event type.\r\n         * @param {String} type The type of event to remove a listener from.\r\n         * @param {Function} listener The function to remove from the event.\r\n         * @return {void}\r\n         * @method removeListener\r\n         */\r\n        removeListener: function(type, listener){\r\n            if (this._listeners[type]){\r\n                var listeners = this._listeners[type];\r\n                for (var i=0, len=listeners.length; i < len; i++){\r\n                    if (listeners[i] === listener){\r\n                        listeners.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Convenient way to read through strings.\r\n     * @namespace parserlib.util\r\n     * @class StringReader\r\n     * @constructor\r\n     * @param {String} text The text to read.\r\n     */\r\n    function StringReader(text){\r\n\r\n        /**\r\n         * The input text with line endings normalized.\r\n         * @property _input\r\n         * @type String\r\n         * @private\r\n         */\r\n        this._input = text.replace(/\\n\\r?/g, \"\\n\");\r\n\r\n\r\n        /**\r\n         * The row for the character to be read next.\r\n         * @property _line\r\n         * @type int\r\n         * @private\r\n         */\r\n        this._line = 1;\r\n\r\n\r\n        /**\r\n         * The column for the character to be read next.\r\n         * @property _col\r\n         * @type int\r\n         * @private\r\n         */\r\n        this._col = 1;\r\n\r\n        /**\r\n         * The index of the character in the input to be read next.\r\n         * @property _cursor\r\n         * @type int\r\n         * @private\r\n         */\r\n        this._cursor = 0;\r\n    }\r\n\r\n    StringReader.prototype = {\r\n\r\n        //restore constructor\r\n        constructor: StringReader,\r\n\r\n        //-------------------------------------------------------------------------\r\n        // Position info\r\n        //-------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Returns the column of the character to be read next.\r\n         * @return {int} The column of the character to be read next.\r\n         * @method getCol\r\n         */\r\n        getCol: function(){\r\n            return this._col;\r\n        },\r\n\r\n        /**\r\n         * Returns the row of the character to be read next.\r\n         * @return {int} The row of the character to be read next.\r\n         * @method getLine\r\n         */\r\n        getLine: function(){\r\n            return this._line ;\r\n        },\r\n\r\n        /**\r\n         * Determines if you're at the end of the input.\r\n         * @return {Boolean} True if there's no more input, false otherwise.\r\n         * @method eof\r\n         */\r\n        eof: function(){\r\n            return (this._cursor == this._input.length);\r\n        },\r\n\r\n        //-------------------------------------------------------------------------\r\n        // Basic reading\r\n        //-------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Reads the next character without advancing the cursor.\r\n         * @param {int} count How many characters to look ahead (default is 1).\r\n         * @return {String} The next character or null if there is no next character.\r\n         * @method peek\r\n         */\r\n        peek: function(count){\r\n            var c = null;\r\n            count = (typeof count == \"undefined\" ? 1 : count);\r\n\r\n            //if we're not at the end of the input...\r\n            if (this._cursor < this._input.length){\r\n\r\n                //get character and increment cursor and column\r\n                c = this._input.charAt(this._cursor + count - 1);\r\n            }\r\n\r\n            return c;\r\n        },\r\n\r\n        /**\r\n         * Reads the next character from the input and adjusts the row and column\r\n         * accordingly.\r\n         * @return {String} The next character or null if there is no next character.\r\n         * @method read\r\n         */\r\n        read: function(){\r\n            var c = null;\r\n\r\n            //if we're not at the end of the input...\r\n            if (this._cursor < this._input.length){\r\n\r\n                //if the last character was a newline, increment row count\r\n                //and reset column count\r\n                if (this._input.charAt(this._cursor) == \"\\n\"){\r\n                    this._line++;\r\n                    this._col=1;\r\n                } else {\r\n                    this._col++;\r\n                }\r\n\r\n                //get character and increment cursor and column\r\n                c = this._input.charAt(this._cursor++);\r\n            }\r\n\r\n            return c;\r\n        },\r\n\r\n        //-------------------------------------------------------------------------\r\n        // Misc\r\n        //-------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Saves the current location so it can be returned to later.\r\n         * @method mark\r\n         * @return {void}\r\n         */\r\n        mark: function(){\r\n            this._bookmark = {\r\n                cursor: this._cursor,\r\n                line:   this._line,\r\n                col:    this._col\r\n            };\r\n        },\r\n\r\n        reset: function(){\r\n            if (this._bookmark){\r\n                this._cursor = this._bookmark.cursor;\r\n                this._line = this._bookmark.line;\r\n                this._col = this._bookmark.col;\r\n                delete this._bookmark;\r\n            }\r\n        },\r\n\r\n        //-------------------------------------------------------------------------\r\n        // Advanced reading\r\n        //-------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Reads up to and including the given string. Throws an error if that\r\n         * string is not found.\r\n         * @param {String} pattern The string to read.\r\n         * @return {String} The string when it is found.\r\n         * @throws Error when the string pattern is not found.\r\n         * @method readTo\r\n         */\r\n        readTo: function(pattern){\r\n\r\n            var buffer = \"\",\r\n                c;\r\n\r\n            /*\r\n             * First, buffer must be the same length as the pattern.\r\n             * Then, buffer must end with the pattern or else reach the\r\n             * end of the input.\r\n             */\r\n            while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) != buffer.length - pattern.length){\r\n                c = this.read();\r\n                if (c){\r\n                    buffer += c;\r\n                } else {\r\n                    throw new Error(\"Expected \\\"\" + pattern + \"\\\" at line \" + this._line  + \", col \" + this._col + \".\");\r\n                }\r\n            }\r\n\r\n            return buffer;\r\n\r\n        },\r\n\r\n        /**\r\n         * Reads characters while each character causes the given\r\n         * filter function to return true. The function is passed\r\n         * in each character and either returns true to continue\r\n         * reading or false to stop.\r\n         * @param {Function} filter The function to read on each character.\r\n         * @return {String} The string made up of all characters that passed the\r\n         *      filter check.\r\n         * @method readWhile\r\n         */\r\n        readWhile: function(filter){\r\n\r\n            var buffer = \"\",\r\n                c = this.read();\r\n\r\n            while(c !== null && filter(c)){\r\n                buffer += c;\r\n                c = this.read();\r\n            }\r\n\r\n            return buffer;\r\n\r\n        },\r\n\r\n        /**\r\n         * Reads characters that match either text or a regular expression and\r\n         * returns those characters. If a match is found, the row and column\r\n         * are adjusted; if no match is found, the reader's state is unchanged.\r\n         * reading or false to stop.\r\n         * @param {String|RegExp} matchter If a string, then the literal string\r\n         *      value is searched for. If a regular expression, then any string\r\n         *      matching the pattern is search for.\r\n         * @return {String} The string made up of all characters that matched or\r\n         *      null if there was no match.\r\n         * @method readMatch\r\n         */\r\n        readMatch: function(matcher){\r\n\r\n            var source = this._input.substring(this._cursor),\r\n                value = null;\r\n\r\n            //if it's a string, just do a straight match\r\n            if (typeof matcher == \"string\"){\r\n                if (source.indexOf(matcher) === 0){\r\n                    value = this.readCount(matcher.length);\r\n                }\r\n            } else if (matcher instanceof RegExp){\r\n                if (matcher.test(source)){\r\n                    value = this.readCount(RegExp.lastMatch.length);\r\n                }\r\n            }\r\n\r\n            return value;\r\n        },\r\n\r\n\r\n        /**\r\n         * Reads a given number of characters. If the end of the input is reached,\r\n         * it reads only the remaining characters and does not throw an error.\r\n         * @param {int} count The number of characters to read.\r\n         * @return {String} The string made up the read characters.\r\n         * @method readCount\r\n         */\r\n        readCount: function(count){\r\n            var buffer = \"\";\r\n\r\n            while(count--){\r\n                buffer += this.read();\r\n            }\r\n\r\n            return buffer;\r\n        }\r\n\r\n    };\r\n    /**\r\n     * Type to use when a syntax error occurs.\r\n     * @class SyntaxError\r\n     * @namespace parserlib.util\r\n     * @constructor\r\n     * @param {String} message The error message.\r\n     * @param {int} line The line at which the error occurred.\r\n     * @param {int} col The column at which the error occurred.\r\n     */\r\n    function SyntaxError(message, line, col){\r\n\r\n        /**\r\n         * The column at which the error occurred.\r\n         * @type int\r\n         * @property col\r\n         */\r\n        this.col = col;\r\n\r\n        /**\r\n         * The line at which the error occurred.\r\n         * @type int\r\n         * @property line\r\n         */\r\n        this.line = line;\r\n\r\n        /**\r\n         * The text representation of the unit.\r\n         * @type String\r\n         * @property text\r\n         */\r\n        this.message = message;\r\n\r\n    }\r\n\r\n    //inherit from Error\r\n    SyntaxError.prototype = new Error();\r\n    /**\r\n     * Base type to represent a single syntactic unit.\r\n     * @class SyntaxUnit\r\n     * @namespace parserlib.util\r\n     * @constructor\r\n     * @param {String} text The text of the unit.\r\n     * @param {int} line The line of text on which the unit resides.\r\n     * @param {int} col The column of text on which the unit resides.\r\n     */\r\n    function SyntaxUnit(text, line, col, type){\r\n\r\n\r\n        /**\r\n         * The column of text on which the unit resides.\r\n         * @type int\r\n         * @property col\r\n         */\r\n        this.col = col;\r\n\r\n        /**\r\n         * The line of text on which the unit resides.\r\n         * @type int\r\n         * @property line\r\n         */\r\n        this.line = line;\r\n\r\n        /**\r\n         * The text representation of the unit.\r\n         * @type String\r\n         * @property text\r\n         */\r\n        this.text = text;\r\n\r\n        /**\r\n         * The type of syntax unit.\r\n         * @type int\r\n         * @property type\r\n         */\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * Create a new syntax unit based solely on the given token.\r\n     * Convenience method for creating a new syntax unit when\r\n     * it represents a single token instead of multiple.\r\n     * @param {Object} token The token object to represent.\r\n     * @return {parserlib.util.SyntaxUnit} The object representing the token.\r\n     * @static\r\n     * @method fromToken\r\n     */\r\n    SyntaxUnit.fromToken = function(token){\r\n        return new SyntaxUnit(token.value, token.startLine, token.startCol);\r\n    };\r\n\r\n    SyntaxUnit.prototype = {\r\n\r\n        //restore constructor\r\n        constructor: SyntaxUnit,\r\n\r\n        /**\r\n         * Returns the text representation of the unit.\r\n         * @return {String} The text representation of the unit.\r\n         * @method valueOf\r\n         */\r\n        valueOf: function(){\r\n            return this.toString();\r\n        },\r\n\r\n        /**\r\n         * Returns the text representation of the unit.\r\n         * @return {String} The text representation of the unit.\r\n         * @method toString\r\n         */\r\n        toString: function(){\r\n            return this.text;\r\n        }\r\n\r\n    };\r\n    /*global StringReader, SyntaxError*/\r\n\r\n    /**\r\n     * Generic TokenStream providing base functionality.\r\n     * @class TokenStreamBase\r\n     * @namespace parserlib.util\r\n     * @constructor\r\n     * @param {String|StringReader} input The text to tokenize or a reader from\r\n     *      which to read the input.\r\n     */\r\n    function TokenStreamBase(input, tokenData){\r\n\r\n        /**\r\n         * The string reader for easy access to the text.\r\n         * @type StringReader\r\n         * @property _reader\r\n         * @private\r\n         */\r\n        this._reader = input ? new StringReader(input.toString()) : null;\r\n\r\n        /**\r\n         * Token object for the last consumed token.\r\n         * @type Token\r\n         * @property _token\r\n         * @private\r\n         */\r\n        this._token = null;\r\n\r\n        /**\r\n         * The array of token information.\r\n         * @type Array\r\n         * @property _tokenData\r\n         * @private\r\n         */\r\n        this._tokenData = tokenData;\r\n\r\n        /**\r\n         * Lookahead token buffer.\r\n         * @type Array\r\n         * @property _lt\r\n         * @private\r\n         */\r\n        this._lt = [];\r\n\r\n        /**\r\n         * Lookahead token buffer index.\r\n         * @type int\r\n         * @property _ltIndex\r\n         * @private\r\n         */\r\n        this._ltIndex = 0;\r\n\r\n        this._ltIndexCache = [];\r\n    }\r\n\r\n    /**\r\n     * Accepts an array of token information and outputs\r\n     * an array of token data containing key-value mappings\r\n     * and matching functions that the TokenStream needs.\r\n     * @param {Array} tokens An array of token descriptors.\r\n     * @return {Array} An array of processed token data.\r\n     * @method createTokenData\r\n     * @static\r\n     */\r\n    TokenStreamBase.createTokenData = function(tokens){\r\n\r\n        var nameMap     = [],\r\n            typeMap     = {},\r\n            tokenData     = tokens.concat([]),\r\n            i            = 0,\r\n            len            = tokenData.length+1;\r\n\r\n        tokenData.UNKNOWN = -1;\r\n        tokenData.unshift({name:\"EOF\"});\r\n\r\n        for (; i < len; i++){\r\n            nameMap.push(tokenData[i].name);\r\n            tokenData[tokenData[i].name] = i;\r\n            if (tokenData[i].text){\r\n                typeMap[tokenData[i].text] = i;\r\n            }\r\n        }\r\n\r\n        tokenData.name = function(tt){\r\n            return nameMap[tt];\r\n        };\r\n\r\n        tokenData.type = function(c){\r\n            return typeMap[c];\r\n        };\r\n\r\n        return tokenData;\r\n    };\r\n\r\n    TokenStreamBase.prototype = {\r\n\r\n        //restore constructor\r\n        constructor: TokenStreamBase,\r\n\r\n        //-------------------------------------------------------------------------\r\n        // Matching methods\r\n        //-------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Determines if the next token matches the given token type.\r\n         * If so, that token is consumed; if not, the token is placed\r\n         * back onto the token stream. You can pass in any number of\r\n         * token types and this will return true if any of the token\r\n         * types is found.\r\n         * @param {int|int[]} tokenTypes Either a single token type or an array of\r\n         *      token types that the next token might be. If an array is passed,\r\n         *      it's assumed that the token can be any of these.\r\n         * @param {variant} channel (Optional) The channel to read from. If not\r\n         *      provided, reads from the default (unnamed) channel.\r\n         * @return {Boolean} True if the token type matches, false if not.\r\n         * @method match\r\n         */\r\n        match: function(tokenTypes, channel){\r\n\r\n            //always convert to an array, makes things easier\r\n            if (!(tokenTypes instanceof Array)){\r\n                tokenTypes = [tokenTypes];\r\n            }\r\n\r\n            var tt  = this.get(channel),\r\n                i   = 0,\r\n                len = tokenTypes.length;\r\n\r\n            while(i < len){\r\n                if (tt == tokenTypes[i++]){\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            //no match found, put the token back\r\n            this.unget();\r\n            return false;\r\n        },\r\n\r\n        /**\r\n         * Determines if the next token matches the given token type.\r\n         * If so, that token is consumed; if not, an error is thrown.\r\n         * @param {int|int[]} tokenTypes Either a single token type or an array of\r\n         *      token types that the next token should be. If an array is passed,\r\n         *      it's assumed that the token must be one of these.\r\n         * @param {variant} channel (Optional) The channel to read from. If not\r\n         *      provided, reads from the default (unnamed) channel.\r\n         * @return {void}\r\n         * @method mustMatch\r\n         */\r\n        mustMatch: function(tokenTypes, channel){\r\n\r\n            var token;\r\n\r\n            //always convert to an array, makes things easier\r\n            if (!(tokenTypes instanceof Array)){\r\n                tokenTypes = [tokenTypes];\r\n            }\r\n\r\n            if (!this.match.apply(this, arguments)){\r\n                token = this.LT(1);\r\n                throw new SyntaxError(\"Expected \" + this._tokenData[tokenTypes[0]].name +\r\n                    \" at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\r\n            }\r\n        },\r\n\r\n        //-------------------------------------------------------------------------\r\n        // Consuming methods\r\n        //-------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Keeps reading from the token stream until either one of the specified\r\n         * token types is found or until the end of the input is reached.\r\n         * @param {int|int[]} tokenTypes Either a single token type or an array of\r\n         *      token types that the next token should be. If an array is passed,\r\n         *      it's assumed that the token must be one of these.\r\n         * @param {variant} channel (Optional) The channel to read from. If not\r\n         *      provided, reads from the default (unnamed) channel.\r\n         * @return {void}\r\n         * @method advance\r\n         */\r\n        advance: function(tokenTypes, channel){\r\n\r\n            while(this.LA(0) !== 0 && !this.match(tokenTypes, channel)){\r\n                this.get();\r\n            }\r\n\r\n            return this.LA(0);\r\n        },\r\n\r\n        /**\r\n         * Consumes the next token from the token stream.\r\n         * @return {int} The token type of the token that was just consumed.\r\n         * @method get\r\n         */\r\n        get: function(channel){\r\n\r\n            var tokenInfo   = this._tokenData,\r\n                reader      = this._reader,\r\n                value,\r\n                i           =0,\r\n                len         = tokenInfo.length,\r\n                found       = false,\r\n                token,\r\n                info;\r\n\r\n            //check the lookahead buffer first\r\n            if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length){\r\n\r\n                i++;\r\n                this._token = this._lt[this._ltIndex++];\r\n                info = tokenInfo[this._token.type];\r\n\r\n                //obey channels logic\r\n                while((info.channel !== undefined && channel !== info.channel) &&\r\n                        this._ltIndex < this._lt.length){\r\n                    this._token = this._lt[this._ltIndex++];\r\n                    info = tokenInfo[this._token.type];\r\n                    i++;\r\n                }\r\n\r\n                //here be dragons\r\n                if ((info.channel === undefined || channel === info.channel) &&\r\n                        this._ltIndex <= this._lt.length){\r\n                    this._ltIndexCache.push(i);\r\n                    return this._token.type;\r\n                }\r\n            }\r\n\r\n            //call token retriever method\r\n            token = this._getToken();\r\n\r\n            //if it should be hidden, don't save a token\r\n            if (token.type > -1 && !tokenInfo[token.type].hide){\r\n\r\n                //apply token channel\r\n                token.channel = tokenInfo[token.type].channel;\r\n\r\n                //save for later\r\n                this._token = token;\r\n                this._lt.push(token);\r\n\r\n                //save space that will be moved (must be done before array is truncated)\r\n                this._ltIndexCache.push(this._lt.length - this._ltIndex + i);\r\n\r\n                //keep the buffer under 5 items\r\n                if (this._lt.length > 5){\r\n                    this._lt.shift();\r\n                }\r\n\r\n                //also keep the shift buffer under 5 items\r\n                if (this._ltIndexCache.length > 5){\r\n                    this._ltIndexCache.shift();\r\n                }\r\n\r\n                //update lookahead index\r\n                this._ltIndex = this._lt.length;\r\n            }\r\n\r\n            /*\r\n             * Skip to the next token if:\r\n             * 1. The token type is marked as hidden.\r\n             * 2. The token type has a channel specified and it isn't the current channel.\r\n             */\r\n            info = tokenInfo[token.type];\r\n            if (info &&\r\n                    (info.hide ||\r\n                    (info.channel !== undefined && channel !== info.channel))){\r\n                return this.get(channel);\r\n            } else {\r\n                //return just the type\r\n                return token.type;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Looks ahead a certain number of tokens and returns the token type at\r\n         * that position. This will throw an error if you lookahead past the\r\n         * end of input, past the size of the lookahead buffer, or back past\r\n         * the first token in the lookahead buffer.\r\n         * @param {int} The index of the token type to retrieve. 0 for the\r\n         *      current token, 1 for the next, -1 for the previous, etc.\r\n         * @return {int} The token type of the token in the given position.\r\n         * @method LA\r\n         */\r\n        LA: function(index){\r\n            var total = index,\r\n                tt;\r\n            if (index > 0){\r\n                //TODO: Store 5 somewhere\r\n                if (index > 5){\r\n                    throw new Error(\"Too much lookahead.\");\r\n                }\r\n\r\n                //get all those tokens\r\n                while(total){\r\n                    tt = this.get();\r\n                    total--;\r\n                }\r\n\r\n                //unget all those tokens\r\n                while(total < index){\r\n                    this.unget();\r\n                    total++;\r\n                }\r\n            } else if (index < 0){\r\n\r\n                if(this._lt[this._ltIndex+index]){\r\n                    tt = this._lt[this._ltIndex+index].type;\r\n                } else {\r\n                    throw new Error(\"Too much lookbehind.\");\r\n                }\r\n\r\n            } else {\r\n                tt = this._token.type;\r\n            }\r\n\r\n            return tt;\r\n\r\n        },\r\n\r\n        /**\r\n         * Looks ahead a certain number of tokens and returns the token at\r\n         * that position. This will throw an error if you lookahead past the\r\n         * end of input, past the size of the lookahead buffer, or back past\r\n         * the first token in the lookahead buffer.\r\n         * @param {int} The index of the token type to retrieve. 0 for the\r\n         *      current token, 1 for the next, -1 for the previous, etc.\r\n         * @return {Object} The token of the token in the given position.\r\n         * @method LA\r\n         */\r\n        LT: function(index){\r\n\r\n            //lookahead first to prime the token buffer\r\n            this.LA(index);\r\n\r\n            //now find the token, subtract one because _ltIndex is already at the next index\r\n            return this._lt[this._ltIndex+index-1];\r\n        },\r\n\r\n        /**\r\n         * Returns the token type for the next token in the stream without\r\n         * consuming it.\r\n         * @return {int} The token type of the next token in the stream.\r\n         * @method peek\r\n         */\r\n        peek: function(){\r\n            return this.LA(1);\r\n        },\r\n\r\n        /**\r\n         * Returns the actual token object for the last consumed token.\r\n         * @return {Token} The token object for the last consumed token.\r\n         * @method token\r\n         */\r\n        token: function(){\r\n            return this._token;\r\n        },\r\n\r\n        /**\r\n         * Returns the name of the token for the given token type.\r\n         * @param {int} tokenType The type of token to get the name of.\r\n         * @return {String} The name of the token or \"UNKNOWN_TOKEN\" for any\r\n         *      invalid token type.\r\n         * @method tokenName\r\n         */\r\n        tokenName: function(tokenType){\r\n            if (tokenType < 0 || tokenType > this._tokenData.length){\r\n                return \"UNKNOWN_TOKEN\";\r\n            } else {\r\n                return this._tokenData[tokenType].name;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns the token type value for the given token name.\r\n         * @param {String} tokenName The name of the token whose value should be returned.\r\n         * @return {int} The token type value for the given token name or -1\r\n         *      for an unknown token.\r\n         * @method tokenName\r\n         */\r\n        tokenType: function(tokenName){\r\n            return this._tokenData[tokenName] || -1;\r\n        },\r\n\r\n        /**\r\n         * Returns the last consumed token to the token stream.\r\n         * @method unget\r\n         */\r\n        unget: function(){\r\n            //if (this._ltIndex > -1){\r\n            if (this._ltIndexCache.length){\r\n                this._ltIndex -= this._ltIndexCache.pop();//--;\r\n                this._token = this._lt[this._ltIndex - 1];\r\n            } else {\r\n                throw new Error(\"Too much lookahead.\");\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n\r\n\r\n\r\n    parserlib.util = {\r\n        StringReader: StringReader,\r\n        SyntaxError : SyntaxError,\r\n        SyntaxUnit  : SyntaxUnit,\r\n        EventTarget : EventTarget,\r\n        TokenStreamBase : TokenStreamBase\r\n    };\r\n\r\n\r\n    var Colors = {\r\n        aliceblue       :\"#f0f8ff\",\r\n        antiquewhite    :\"#faebd7\",\r\n        aqua            :\"#00ffff\",\r\n        aquamarine      :\"#7fffd4\",\r\n        azure           :\"#f0ffff\",\r\n        beige           :\"#f5f5dc\",\r\n        bisque          :\"#ffe4c4\",\r\n        black           :\"#000000\",\r\n        blanchedalmond  :\"#ffebcd\",\r\n        blue            :\"#0000ff\",\r\n        blueviolet      :\"#8a2be2\",\r\n        brown           :\"#a52a2a\",\r\n        burlywood       :\"#deb887\",\r\n        cadetblue       :\"#5f9ea0\",\r\n        chartreuse      :\"#7fff00\",\r\n        chocolate       :\"#d2691e\",\r\n        coral           :\"#ff7f50\",\r\n        cornflowerblue  :\"#6495ed\",\r\n        cornsilk        :\"#fff8dc\",\r\n        crimson         :\"#dc143c\",\r\n        cyan            :\"#00ffff\",\r\n        darkblue        :\"#00008b\",\r\n        darkcyan        :\"#008b8b\",\r\n        darkgoldenrod   :\"#b8860b\",\r\n        darkgray        :\"#a9a9a9\",\r\n        darkgreen       :\"#006400\",\r\n        darkkhaki       :\"#bdb76b\",\r\n        darkmagenta     :\"#8b008b\",\r\n        darkolivegreen  :\"#556b2f\",\r\n        darkorange      :\"#ff8c00\",\r\n        darkorchid      :\"#9932cc\",\r\n        darkred         :\"#8b0000\",\r\n        darksalmon      :\"#e9967a\",\r\n        darkseagreen    :\"#8fbc8f\",\r\n        darkslateblue   :\"#483d8b\",\r\n        darkslategray   :\"#2f4f4f\",\r\n        darkturquoise   :\"#00ced1\",\r\n        darkviolet      :\"#9400d3\",\r\n        deeppink        :\"#ff1493\",\r\n        deepskyblue     :\"#00bfff\",\r\n        dimgray         :\"#696969\",\r\n        dodgerblue      :\"#1e90ff\",\r\n        firebrick       :\"#b22222\",\r\n        floralwhite     :\"#fffaf0\",\r\n        forestgreen     :\"#228b22\",\r\n        fuchsia         :\"#ff00ff\",\r\n        gainsboro       :\"#dcdcdc\",\r\n        ghostwhite      :\"#f8f8ff\",\r\n        gold            :\"#ffd700\",\r\n        goldenrod       :\"#daa520\",\r\n        gray            :\"#808080\",\r\n        green           :\"#008000\",\r\n        greenyellow     :\"#adff2f\",\r\n        honeydew        :\"#f0fff0\",\r\n        hotpink         :\"#ff69b4\",\r\n        indianred       :\"#cd5c5c\",\r\n        indigo          :\"#4b0082\",\r\n        ivory           :\"#fffff0\",\r\n        khaki           :\"#f0e68c\",\r\n        lavender        :\"#e6e6fa\",\r\n        lavenderblush   :\"#fff0f5\",\r\n        lawngreen       :\"#7cfc00\",\r\n        lemonchiffon    :\"#fffacd\",\r\n        lightblue       :\"#add8e6\",\r\n        lightcoral      :\"#f08080\",\r\n        lightcyan       :\"#e0ffff\",\r\n        lightgoldenrodyellow  :\"#fafad2\",\r\n        lightgray       :\"#d3d3d3\",\r\n        lightgreen      :\"#90ee90\",\r\n        lightpink       :\"#ffb6c1\",\r\n        lightsalmon     :\"#ffa07a\",\r\n        lightseagreen   :\"#20b2aa\",\r\n        lightskyblue    :\"#87cefa\",\r\n        lightslategray  :\"#778899\",\r\n        lightsteelblue  :\"#b0c4de\",\r\n        lightyellow     :\"#ffffe0\",\r\n        lime            :\"#00ff00\",\r\n        limegreen       :\"#32cd32\",\r\n        linen           :\"#faf0e6\",\r\n        magenta         :\"#ff00ff\",\r\n        maroon          :\"#800000\",\r\n        mediumaquamarine:\"#66cdaa\",\r\n        mediumblue      :\"#0000cd\",\r\n        mediumorchid    :\"#ba55d3\",\r\n        mediumpurple    :\"#9370d8\",\r\n        mediumseagreen  :\"#3cb371\",\r\n        mediumslateblue :\"#7b68ee\",\r\n        mediumspringgreen   :\"#00fa9a\",\r\n        mediumturquoise :\"#48d1cc\",\r\n        mediumvioletred :\"#c71585\",\r\n        midnightblue    :\"#191970\",\r\n        mintcream       :\"#f5fffa\",\r\n        mistyrose       :\"#ffe4e1\",\r\n        moccasin        :\"#ffe4b5\",\r\n        navajowhite     :\"#ffdead\",\r\n        navy            :\"#000080\",\r\n        oldlace         :\"#fdf5e6\",\r\n        olive           :\"#808000\",\r\n        olivedrab       :\"#6b8e23\",\r\n        orange          :\"#ffa500\",\r\n        orangered       :\"#ff4500\",\r\n        orchid          :\"#da70d6\",\r\n        palegoldenrod   :\"#eee8aa\",\r\n        palegreen       :\"#98fb98\",\r\n        paleturquoise   :\"#afeeee\",\r\n        palevioletred   :\"#d87093\",\r\n        papayawhip      :\"#ffefd5\",\r\n        peachpuff       :\"#ffdab9\",\r\n        peru            :\"#cd853f\",\r\n        pink            :\"#ffc0cb\",\r\n        plum            :\"#dda0dd\",\r\n        powderblue      :\"#b0e0e6\",\r\n        purple          :\"#800080\",\r\n        red             :\"#ff0000\",\r\n        rosybrown       :\"#bc8f8f\",\r\n        royalblue       :\"#4169e1\",\r\n        saddlebrown     :\"#8b4513\",\r\n        salmon          :\"#fa8072\",\r\n        sandybrown      :\"#f4a460\",\r\n        seagreen        :\"#2e8b57\",\r\n        seashell        :\"#fff5ee\",\r\n        sienna          :\"#a0522d\",\r\n        silver          :\"#c0c0c0\",\r\n        skyblue         :\"#87ceeb\",\r\n        slateblue       :\"#6a5acd\",\r\n        slategray       :\"#708090\",\r\n        snow            :\"#fffafa\",\r\n        springgreen     :\"#00ff7f\",\r\n        steelblue       :\"#4682b4\",\r\n        tan             :\"#d2b48c\",\r\n        teal            :\"#008080\",\r\n        thistle         :\"#d8bfd8\",\r\n        tomato          :\"#ff6347\",\r\n        turquoise       :\"#40e0d0\",\r\n        violet          :\"#ee82ee\",\r\n        wheat           :\"#f5deb3\",\r\n        white           :\"#ffffff\",\r\n        whitesmoke      :\"#f5f5f5\",\r\n        yellow          :\"#ffff00\",\r\n        yellowgreen     :\"#9acd32\",\r\n        //CSS2 system colors http://www.w3.org/TR/css3-color/#css2-system\r\n        activeBorder        :\"Active window border.\",\r\n        activecaption       :\"Active window caption.\",\r\n        appworkspace        :\"Background color of multiple document interface.\",\r\n        background          :\"Desktop background.\",\r\n        buttonface          :\"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.\",\r\n        buttonhighlight     :\"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\",\r\n        buttonshadow        :\"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\",\r\n        buttontext          :\"Text on push buttons.\",\r\n        captiontext         :\"Text in caption, size box, and scrollbar arrow box.\",\r\n        graytext            :\"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.\",\r\n        highlight           :\"Item(s) selected in a control.\",\r\n        highlighttext       :\"Text of item(s) selected in a control.\",\r\n        inactiveborder      :\"Inactive window border.\",\r\n        inactivecaption     :\"Inactive window caption.\",\r\n        inactivecaptiontext :\"Color of text in an inactive caption.\",\r\n        infobackground      :\"Background color for tooltip controls.\",\r\n        infotext            :\"Text color for tooltip controls.\",\r\n        menu                :\"Menu background.\",\r\n        menutext            :\"Text in menus.\",\r\n        scrollbar           :\"Scroll bar gray area.\",\r\n        threeddarkshadow    :\"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\r\n        threedface          :\"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\r\n        threedhighlight     :\"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\r\n        threedlightshadow   :\"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\r\n        threedshadow        :\"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\r\n        window              :\"Window background.\",\r\n        windowframe         :\"Window frame.\",\r\n        windowtext          :\"Text in windows.\"\r\n    };\r\n    /*global SyntaxUnit, Parser*/\r\n    /**\r\n     * Represents a selector combinator (whitespace, +, >).\r\n     * @namespace parserlib.css\r\n     * @class Combinator\r\n     * @extends parserlib.util.SyntaxUnit\r\n     * @constructor\r\n     * @param {String} text The text representation of the unit.\r\n     * @param {int} line The line of text on which the unit resides.\r\n     * @param {int} col The column of text on which the unit resides.\r\n     */\r\n    function Combinator(text, line, col){\r\n\r\n        SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);\r\n\r\n        /**\r\n         * The type of modifier.\r\n         * @type String\r\n         * @property type\r\n         */\r\n        this.type = \"unknown\";\r\n\r\n        //pretty simple\r\n        if (/^\\s+$/.test(text)){\r\n            this.type = \"descendant\";\r\n        } else if (text == \">\"){\r\n            this.type = \"child\";\r\n        } else if (text == \"+\"){\r\n            this.type = \"adjacent-sibling\";\r\n        } else if (text == \"~\"){\r\n            this.type = \"sibling\";\r\n        }\r\n\r\n    }\r\n\r\n    Combinator.prototype = new SyntaxUnit();\r\n    Combinator.prototype.constructor = Combinator;\r\n\r\n\r\n    /*global SyntaxUnit, Parser*/\r\n    /**\r\n     * Represents a media feature, such as max-width:500.\r\n     * @namespace parserlib.css\r\n     * @class MediaFeature\r\n     * @extends parserlib.util.SyntaxUnit\r\n     * @constructor\r\n     * @param {SyntaxUnit} name The name of the feature.\r\n     * @param {SyntaxUnit} value The value of the feature or null if none.\r\n     */\r\n    function MediaFeature(name, value){\r\n\r\n        SyntaxUnit.call(this, \"(\" + name + (value !== null ? \":\" + value : \"\") + \")\", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);\r\n\r\n        /**\r\n         * The name of the media feature\r\n         * @type String\r\n         * @property name\r\n         */\r\n        this.name = name;\r\n\r\n        /**\r\n         * The value for the feature or null if there is none.\r\n         * @type SyntaxUnit\r\n         * @property value\r\n         */\r\n        this.value = value;\r\n    }\r\n\r\n    MediaFeature.prototype = new SyntaxUnit();\r\n    MediaFeature.prototype.constructor = MediaFeature;\r\n\r\n\r\n    /*global SyntaxUnit, Parser*/\r\n    /**\r\n     * Represents an individual media query.\r\n     * @namespace parserlib.css\r\n     * @class MediaQuery\r\n     * @extends parserlib.util.SyntaxUnit\r\n     * @constructor\r\n     * @param {String} modifier The modifier \"not\" or \"only\" (or null).\r\n     * @param {String} mediaType The type of media (i.e., \"print\").\r\n     * @param {Array} parts Array of selectors parts making up this selector.\r\n     * @param {int} line The line of text on which the unit resides.\r\n     * @param {int} col The column of text on which the unit resides.\r\n     */\r\n    function MediaQuery(modifier, mediaType, features, line, col){\r\n\r\n        SyntaxUnit.call(this, (modifier ? modifier + \" \": \"\") + (mediaType ? mediaType : \"\") + (mediaType && features.length > 0 ? \" and \" : \"\") + features.join(\" and \"), line, col, Parser.MEDIA_QUERY_TYPE);\r\n\r\n        /**\r\n         * The media modifier (\"not\" or \"only\")\r\n         * @type String\r\n         * @property modifier\r\n         */\r\n        this.modifier = modifier;\r\n\r\n        /**\r\n         * The mediaType (i.e., \"print\")\r\n         * @type String\r\n         * @property mediaType\r\n         */\r\n        this.mediaType = mediaType;\r\n\r\n        /**\r\n         * The parts that make up the selector.\r\n         * @type Array\r\n         * @property features\r\n         */\r\n        this.features = features;\r\n\r\n    }\r\n\r\n    MediaQuery.prototype = new SyntaxUnit();\r\n    MediaQuery.prototype.constructor = MediaQuery;\r\n\r\n\r\n    /*global Tokens, TokenStream, SyntaxError, Properties, Validation, ValidationError, SyntaxUnit,\r\n        PropertyValue, PropertyValuePart, SelectorPart, SelectorSubPart, Selector,\r\n        PropertyName, Combinator, MediaFeature, MediaQuery, EventTarget */\r\n\r\n    /**\r\n     * A CSS3 parser.\r\n     * @namespace parserlib.css\r\n     * @class Parser\r\n     * @constructor\r\n     * @param {Object} options (Optional) Various options for the parser:\r\n     *      starHack (true|false) to allow IE6 star hack as valid,\r\n     *      underscoreHack (true|false) to interpret leading underscores\r\n     *      as IE6-7 targeting for known properties, ieFilters (true|false)\r\n     *      to indicate that IE < 8 filters should be accepted and not throw\r\n     *      syntax errors.\r\n     */\r\n    function Parser(options){\r\n\r\n        //inherit event functionality\r\n        EventTarget.call(this);\r\n\r\n\r\n        this.options = options || {};\r\n\r\n        this._tokenStream = null;\r\n    }\r\n\r\n    //Static constants\r\n    Parser.DEFAULT_TYPE = 0;\r\n    Parser.COMBINATOR_TYPE = 1;\r\n    Parser.MEDIA_FEATURE_TYPE = 2;\r\n    Parser.MEDIA_QUERY_TYPE = 3;\r\n    Parser.PROPERTY_NAME_TYPE = 4;\r\n    Parser.PROPERTY_VALUE_TYPE = 5;\r\n    Parser.PROPERTY_VALUE_PART_TYPE = 6;\r\n    Parser.SELECTOR_TYPE = 7;\r\n    Parser.SELECTOR_PART_TYPE = 8;\r\n    Parser.SELECTOR_SUB_PART_TYPE = 9;\r\n\r\n    Parser.prototype = function(){\r\n\r\n        var proto = new EventTarget(),  //new prototype\r\n            prop,\r\n            additions =  {\r\n\r\n                //restore constructor\r\n                constructor: Parser,\r\n\r\n                //instance constants - yuck\r\n                DEFAULT_TYPE : 0,\r\n                COMBINATOR_TYPE : 1,\r\n                MEDIA_FEATURE_TYPE : 2,\r\n                MEDIA_QUERY_TYPE : 3,\r\n                PROPERTY_NAME_TYPE : 4,\r\n                PROPERTY_VALUE_TYPE : 5,\r\n                PROPERTY_VALUE_PART_TYPE : 6,\r\n                SELECTOR_TYPE : 7,\r\n                SELECTOR_PART_TYPE : 8,\r\n                SELECTOR_SUB_PART_TYPE : 9,\r\n\r\n                //-----------------------------------------------------------------\r\n                // Grammar\r\n                //-----------------------------------------------------------------\r\n\r\n                _stylesheet: function(){\r\n\r\n                    /*\r\n                     * stylesheet\r\n                     *  : [ CHARSET_SYM S* STRING S* ';' ]?\r\n                     *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*\r\n                     *    [ namespace [S|CDO|CDC]* ]*\r\n                     *    [ [ ruleset | media | page | font_face | keyframes ] [S|CDO|CDC]* ]*\r\n                     *  ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        charset     = null,\r\n                        count,\r\n                        token,\r\n                        tt;\r\n\r\n                    this.fire(\"startstylesheet\");\r\n\r\n                    //try to read character set\r\n                    this._charset();\r\n\r\n                    this._skipCruft();\r\n\r\n                    //try to read imports - may be more than one\r\n                    while (tokenStream.peek() == Tokens.IMPORT_SYM){\r\n                        this._import();\r\n                        this._skipCruft();\r\n                    }\r\n\r\n                    //try to read namespaces - may be more than one\r\n                    while (tokenStream.peek() == Tokens.NAMESPACE_SYM){\r\n                        this._namespace();\r\n                        this._skipCruft();\r\n                    }\r\n\r\n                    //get the next token\r\n                    tt = tokenStream.peek();\r\n\r\n                    //try to read the rest\r\n                    while(tt > Tokens.EOF){\r\n\r\n                        try {\r\n\r\n                            switch(tt){\r\n                                case Tokens.MEDIA_SYM:\r\n                                    this._media();\r\n                                    this._skipCruft();\r\n                                    break;\r\n                                case Tokens.PAGE_SYM:\r\n                                    this._page();\r\n                                    this._skipCruft();\r\n                                    break;\r\n                                case Tokens.FONT_FACE_SYM:\r\n                                    this._font_face();\r\n                                    this._skipCruft();\r\n                                    break;\r\n                                case Tokens.KEYFRAMES_SYM:\r\n                                    this._keyframes();\r\n                                    this._skipCruft();\r\n                                    break;\r\n                                case Tokens.VIEWPORT_SYM:\r\n                                    this._viewport();\r\n                                    this._skipCruft();\r\n                                    break;\r\n                                case Tokens.UNKNOWN_SYM:  //unknown @ rule\r\n                                    tokenStream.get();\r\n                                    if (!this.options.strict){\r\n\r\n                                        //fire error event\r\n                                        this.fire({\r\n                                            type:       \"error\",\r\n                                            error:      null,\r\n                                            message:    \"Unknown @ rule: \" + tokenStream.LT(0).value + \".\",\r\n                                            line:       tokenStream.LT(0).startLine,\r\n                                            col:        tokenStream.LT(0).startCol\r\n                                        });\r\n\r\n                                        //skip braces\r\n                                        count=0;\r\n                                        while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) == Tokens.LBRACE){\r\n                                            count++;    //keep track of nesting depth\r\n                                        }\r\n\r\n                                        while(count){\r\n                                            tokenStream.advance([Tokens.RBRACE]);\r\n                                            count--;\r\n                                        }\r\n\r\n                                    } else {\r\n                                        //not a syntax error, rethrow it\r\n                                        throw new SyntaxError(\"Unknown @ rule.\", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);\r\n                                    }\r\n                                    break;\r\n                                case Tokens.S:\r\n                                    this._readWhitespace();\r\n                                    break;\r\n                                default:\r\n                                    if(!this._ruleset()){\r\n\r\n                                        //error handling for known issues\r\n                                        switch(tt){\r\n                                            case Tokens.CHARSET_SYM:\r\n                                                token = tokenStream.LT(1);\r\n                                                this._charset(false);\r\n                                                throw new SyntaxError(\"@charset not allowed here.\", token.startLine, token.startCol);\r\n                                            case Tokens.IMPORT_SYM:\r\n                                                token = tokenStream.LT(1);\r\n                                                this._import(false);\r\n                                                throw new SyntaxError(\"@import not allowed here.\", token.startLine, token.startCol);\r\n                                            case Tokens.NAMESPACE_SYM:\r\n                                                token = tokenStream.LT(1);\r\n                                                this._namespace(false);\r\n                                                throw new SyntaxError(\"@namespace not allowed here.\", token.startLine, token.startCol);\r\n                                            default:\r\n                                                tokenStream.get();  //get the last token\r\n                                                this._unexpectedToken(tokenStream.token());\r\n                                        }\r\n\r\n                                    }\r\n                            }\r\n                        } catch(ex) {\r\n                            if (ex instanceof SyntaxError && !this.options.strict){\r\n                                this.fire({\r\n                                    type:       \"error\",\r\n                                    error:      ex,\r\n                                    message:    ex.message,\r\n                                    line:       ex.line,\r\n                                    col:        ex.col\r\n                                });\r\n                            } else {\r\n                                throw ex;\r\n                            }\r\n                        }\r\n\r\n                        tt = tokenStream.peek();\r\n                    }\r\n\r\n                    if (tt != Tokens.EOF){\r\n                        this._unexpectedToken(tokenStream.token());\r\n                    }\r\n\r\n                    this.fire(\"endstylesheet\");\r\n                },\r\n\r\n                _charset: function(emit){\r\n                    var tokenStream = this._tokenStream,\r\n                        charset,\r\n                        token,\r\n                        line,\r\n                        col;\r\n\r\n                    if (tokenStream.match(Tokens.CHARSET_SYM)){\r\n                        line = tokenStream.token().startLine;\r\n                        col = tokenStream.token().startCol;\r\n\r\n                        this._readWhitespace();\r\n                        tokenStream.mustMatch(Tokens.STRING);\r\n\r\n                        token = tokenStream.token();\r\n                        charset = token.value;\r\n\r\n                        this._readWhitespace();\r\n                        tokenStream.mustMatch(Tokens.SEMICOLON);\r\n\r\n                        if (emit !== false){\r\n                            this.fire({\r\n                                type:   \"charset\",\r\n                                charset:charset,\r\n                                line:   line,\r\n                                col:    col\r\n                            });\r\n                        }\r\n                    }\r\n                },\r\n\r\n                _import: function(emit){\r\n                    /*\r\n                     * import\r\n                     *   : IMPORT_SYM S*\r\n                     *    [STRING|URI] S* media_query_list? ';' S*\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        tt,\r\n                        uri,\r\n                        importToken,\r\n                        mediaList   = [];\r\n\r\n                    //read import symbol\r\n                    tokenStream.mustMatch(Tokens.IMPORT_SYM);\r\n                    importToken = tokenStream.token();\r\n                    this._readWhitespace();\r\n\r\n                    tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);\r\n\r\n                    //grab the URI value\r\n                    uri = tokenStream.token().value.replace(/(?:url\\()?[\"']([^\"']+)[\"']\\)?/, \"$1\");\r\n\r\n                    this._readWhitespace();\r\n\r\n                    mediaList = this._media_query_list();\r\n\r\n                    //must end with a semicolon\r\n                    tokenStream.mustMatch(Tokens.SEMICOLON);\r\n                    this._readWhitespace();\r\n\r\n                    if (emit !== false){\r\n                        this.fire({\r\n                            type:   \"import\",\r\n                            uri:    uri,\r\n                            media:  mediaList,\r\n                            line:   importToken.startLine,\r\n                            col:    importToken.startCol\r\n                        });\r\n                    }\r\n\r\n                },\r\n\r\n                _namespace: function(emit){\r\n                    /*\r\n                     * namespace\r\n                     *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        line,\r\n                        col,\r\n                        prefix,\r\n                        uri;\r\n\r\n                    //read import symbol\r\n                    tokenStream.mustMatch(Tokens.NAMESPACE_SYM);\r\n                    line = tokenStream.token().startLine;\r\n                    col = tokenStream.token().startCol;\r\n                    this._readWhitespace();\r\n\r\n                    //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT\r\n                    if (tokenStream.match(Tokens.IDENT)){\r\n                        prefix = tokenStream.token().value;\r\n                        this._readWhitespace();\r\n                    }\r\n\r\n                    tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);\r\n                    /*if (!tokenStream.match(Tokens.STRING)){\r\n                        tokenStream.mustMatch(Tokens.URI);\r\n                    }*/\r\n\r\n                    //grab the URI value\r\n                    uri = tokenStream.token().value.replace(/(?:url\\()?[\"']([^\"']+)[\"']\\)?/, \"$1\");\r\n\r\n                    this._readWhitespace();\r\n\r\n                    //must end with a semicolon\r\n                    tokenStream.mustMatch(Tokens.SEMICOLON);\r\n                    this._readWhitespace();\r\n\r\n                    if (emit !== false){\r\n                        this.fire({\r\n                            type:   \"namespace\",\r\n                            prefix: prefix,\r\n                            uri:    uri,\r\n                            line:   line,\r\n                            col:    col\r\n                        });\r\n                    }\r\n\r\n                },\r\n\r\n                _media: function(){\r\n                    /*\r\n                     * media\r\n                     *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*\r\n                     *   ;\r\n                     */\r\n                    var tokenStream     = this._tokenStream,\r\n                        line,\r\n                        col,\r\n                        mediaList;//       = [];\r\n\r\n                    //look for @media\r\n                    tokenStream.mustMatch(Tokens.MEDIA_SYM);\r\n                    line = tokenStream.token().startLine;\r\n                    col = tokenStream.token().startCol;\r\n\r\n                    this._readWhitespace();\r\n\r\n                    mediaList = this._media_query_list();\r\n\r\n                    tokenStream.mustMatch(Tokens.LBRACE);\r\n                    this._readWhitespace();\r\n\r\n                    this.fire({\r\n                        type:   \"startmedia\",\r\n                        media:  mediaList,\r\n                        line:   line,\r\n                        col:    col\r\n                    });\r\n\r\n                    while(true) {\r\n                        if (tokenStream.peek() == Tokens.PAGE_SYM){\r\n                            this._page();\r\n                        } else   if (tokenStream.peek() == Tokens.FONT_FACE_SYM){\r\n                            this._font_face();\r\n                        } else if (!this._ruleset()){\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    tokenStream.mustMatch(Tokens.RBRACE);\r\n                    this._readWhitespace();\r\n\r\n                    this.fire({\r\n                        type:   \"endmedia\",\r\n                        media:  mediaList,\r\n                        line:   line,\r\n                        col:    col\r\n                    });\r\n                },\r\n\r\n\r\n                //CSS3 Media Queries\r\n                _media_query_list: function(){\r\n                    /*\r\n                     * media_query_list\r\n                     *   : S* [media_query [ ',' S* media_query ]* ]?\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        mediaList   = [];\r\n\r\n\r\n                    this._readWhitespace();\r\n\r\n                    if (tokenStream.peek() == Tokens.IDENT || tokenStream.peek() == Tokens.LPAREN){\r\n                        mediaList.push(this._media_query());\r\n                    }\r\n\r\n                    while(tokenStream.match(Tokens.COMMA)){\r\n                        this._readWhitespace();\r\n                        mediaList.push(this._media_query());\r\n                    }\r\n\r\n                    return mediaList;\r\n                },\r\n\r\n                /*\r\n                 * Note: \"expression\" in the grammar maps to the _media_expression\r\n                 * method.\r\n\r\n                 */\r\n                _media_query: function(){\r\n                    /*\r\n                     * media_query\r\n                     *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*\r\n                     *   | expression [ AND S* expression ]*\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        type        = null,\r\n                        ident       = null,\r\n                        token       = null,\r\n                        expressions = [];\r\n\r\n                    if (tokenStream.match(Tokens.IDENT)){\r\n                        ident = tokenStream.token().value.toLowerCase();\r\n\r\n                        //since there's no custom tokens for these, need to manually check\r\n                        if (ident != \"only\" && ident != \"not\"){\r\n                            tokenStream.unget();\r\n                            ident = null;\r\n                        } else {\r\n                            token = tokenStream.token();\r\n                        }\r\n                    }\r\n\r\n                    this._readWhitespace();\r\n\r\n                    if (tokenStream.peek() == Tokens.IDENT){\r\n                        type = this._media_type();\r\n                        if (token === null){\r\n                            token = tokenStream.token();\r\n                        }\r\n                    } else if (tokenStream.peek() == Tokens.LPAREN){\r\n                        if (token === null){\r\n                            token = tokenStream.LT(1);\r\n                        }\r\n                        expressions.push(this._media_expression());\r\n                    }\r\n\r\n                    if (type === null && expressions.length === 0){\r\n                        return null;\r\n                    } else {\r\n                        this._readWhitespace();\r\n                        while (tokenStream.match(Tokens.IDENT)){\r\n                            if (tokenStream.token().value.toLowerCase() != \"and\"){\r\n                                this._unexpectedToken(tokenStream.token());\r\n                            }\r\n\r\n                            this._readWhitespace();\r\n                            expressions.push(this._media_expression());\r\n                        }\r\n                    }\r\n\r\n                    return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);\r\n                },\r\n\r\n                //CSS3 Media Queries\r\n                _media_type: function(){\r\n                    /*\r\n                     * media_type\r\n                     *   : IDENT\r\n                     *   ;\r\n                     */\r\n                    return this._media_feature();\r\n                },\r\n\r\n                /**\r\n                 * Note: in CSS3 Media Queries, this is called \"expression\".\r\n                 * Renamed here to avoid conflict with CSS3 Selectors\r\n                 * definition of \"expression\". Also note that \"expr\" in the\r\n                 * grammar now maps to \"expression\" from CSS3 selectors.\r\n                 * @method _media_expression\r\n                 * @private\r\n                 */\r\n                _media_expression: function(){\r\n                    /*\r\n                     * expression\r\n                     *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*\r\n                     *  ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        feature     = null,\r\n                        token,\r\n                        expression  = null;\r\n\r\n                    tokenStream.mustMatch(Tokens.LPAREN);\r\n\r\n                    feature = this._media_feature();\r\n                    this._readWhitespace();\r\n\r\n                    if (tokenStream.match(Tokens.COLON)){\r\n                        this._readWhitespace();\r\n                        token = tokenStream.LT(1);\r\n                        expression = this._expression();\r\n                    }\r\n\r\n                    tokenStream.mustMatch(Tokens.RPAREN);\r\n                    this._readWhitespace();\r\n\r\n                    return new MediaFeature(feature, (expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null));\r\n                },\r\n\r\n                //CSS3 Media Queries\r\n                _media_feature: function(){\r\n                    /*\r\n                     * media_feature\r\n                     *   : IDENT\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream;\r\n\r\n                    tokenStream.mustMatch(Tokens.IDENT);\r\n\r\n                    return SyntaxUnit.fromToken(tokenStream.token());\r\n                },\r\n\r\n                //CSS3 Paged Media\r\n                _page: function(){\r\n                    /*\r\n                     * page:\r\n                     *    PAGE_SYM S* IDENT? pseudo_page? S*\r\n                     *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*\r\n                     *    ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        line,\r\n                        col,\r\n                        identifier  = null,\r\n                        pseudoPage  = null;\r\n\r\n                    //look for @page\r\n                    tokenStream.mustMatch(Tokens.PAGE_SYM);\r\n                    line = tokenStream.token().startLine;\r\n                    col = tokenStream.token().startCol;\r\n\r\n                    this._readWhitespace();\r\n\r\n                    if (tokenStream.match(Tokens.IDENT)){\r\n                        identifier = tokenStream.token().value;\r\n\r\n                        //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.\r\n                        if (identifier.toLowerCase() === \"auto\"){\r\n                            this._unexpectedToken(tokenStream.token());\r\n                        }\r\n                    }\r\n\r\n                    //see if there's a colon upcoming\r\n                    if (tokenStream.peek() == Tokens.COLON){\r\n                        pseudoPage = this._pseudo_page();\r\n                    }\r\n\r\n                    this._readWhitespace();\r\n\r\n                    this.fire({\r\n                        type:   \"startpage\",\r\n                        id:     identifier,\r\n                        pseudo: pseudoPage,\r\n                        line:   line,\r\n                        col:    col\r\n                    });\r\n\r\n                    this._readDeclarations(true, true);\r\n\r\n                    this.fire({\r\n                        type:   \"endpage\",\r\n                        id:     identifier,\r\n                        pseudo: pseudoPage,\r\n                        line:   line,\r\n                        col:    col\r\n                    });\r\n\r\n                },\r\n\r\n                //CSS3 Paged Media\r\n                _margin: function(){\r\n                    /*\r\n                     * margin :\r\n                     *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*\r\n                     *    ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        line,\r\n                        col,\r\n                        marginSym   = this._margin_sym();\r\n\r\n                    if (marginSym){\r\n                        line = tokenStream.token().startLine;\r\n                        col = tokenStream.token().startCol;\r\n\r\n                        this.fire({\r\n                            type: \"startpagemargin\",\r\n                            margin: marginSym,\r\n                            line:   line,\r\n                            col:    col\r\n                        });\r\n\r\n                        this._readDeclarations(true);\r\n\r\n                        this.fire({\r\n                            type: \"endpagemargin\",\r\n                            margin: marginSym,\r\n                            line:   line,\r\n                            col:    col\r\n                        });\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                },\r\n\r\n                //CSS3 Paged Media\r\n                _margin_sym: function(){\r\n\r\n                    /*\r\n                     * margin_sym :\r\n                     *    TOPLEFTCORNER_SYM |\r\n                     *    TOPLEFT_SYM |\r\n                     *    TOPCENTER_SYM |\r\n                     *    TOPRIGHT_SYM |\r\n                     *    TOPRIGHTCORNER_SYM |\r\n                     *    BOTTOMLEFTCORNER_SYM |\r\n                     *    BOTTOMLEFT_SYM |\r\n                     *    BOTTOMCENTER_SYM |\r\n                     *    BOTTOMRIGHT_SYM |\r\n                     *    BOTTOMRIGHTCORNER_SYM |\r\n                     *    LEFTTOP_SYM |\r\n                     *    LEFTMIDDLE_SYM |\r\n                     *    LEFTBOTTOM_SYM |\r\n                     *    RIGHTTOP_SYM |\r\n                     *    RIGHTMIDDLE_SYM |\r\n                     *    RIGHTBOTTOM_SYM\r\n                     *    ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream;\r\n\r\n                    if(tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,\r\n                            Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,\r\n                            Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,\r\n                            Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,\r\n                            Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,\r\n                            Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,\r\n                            Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM]))\r\n                    {\r\n                        return SyntaxUnit.fromToken(tokenStream.token());\r\n                    } else {\r\n                        return null;\r\n                    }\r\n\r\n                },\r\n\r\n                _pseudo_page: function(){\r\n                    /*\r\n                     * pseudo_page\r\n                     *   : ':' IDENT\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream;\r\n\r\n                    tokenStream.mustMatch(Tokens.COLON);\r\n                    tokenStream.mustMatch(Tokens.IDENT);\r\n\r\n                    //TODO: CSS3 Paged Media says only \"left\", \"center\", and \"right\" are allowed\r\n\r\n                    return tokenStream.token().value;\r\n                },\r\n\r\n                _font_face: function(){\r\n                    /*\r\n                     * font_face\r\n                     *   : FONT_FACE_SYM S*\r\n                     *     '{' S* declaration [ ';' S* declaration ]* '}' S*\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        line,\r\n                        col;\r\n\r\n                    //look for @page\r\n                    tokenStream.mustMatch(Tokens.FONT_FACE_SYM);\r\n                    line = tokenStream.token().startLine;\r\n                    col = tokenStream.token().startCol;\r\n\r\n                    this._readWhitespace();\r\n\r\n                    this.fire({\r\n                        type:   \"startfontface\",\r\n                        line:   line,\r\n                        col:    col\r\n                    });\r\n\r\n                    this._readDeclarations(true);\r\n\r\n                    this.fire({\r\n                        type:   \"endfontface\",\r\n                        line:   line,\r\n                        col:    col\r\n                    });\r\n                },\r\n\r\n                _viewport: function(){\r\n                    /*\r\n                     * viewport\r\n                     *   : VIEWPORT_SYM S*\r\n                     *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*\r\n                     *   ;\r\n                     */\r\n                     var tokenStream = this._tokenStream,\r\n                        line,\r\n                        col;\r\n\r\n                        tokenStream.mustMatch(Tokens.VIEWPORT_SYM);\r\n                        line = tokenStream.token().startLine;\r\n                        col = tokenStream.token().startCol;\r\n\r\n                        this._readWhitespace();\r\n\r\n                        this.fire({\r\n                            type:   \"startviewport\",\r\n                            line:   line,\r\n                            col:    col\r\n                        });\r\n\r\n                        this._readDeclarations(true);\r\n\r\n                        this.fire({\r\n                            type:   \"endviewport\",\r\n                            line:   line,\r\n                            col:    col\r\n                        });\r\n\r\n                },\r\n\r\n                _operator: function(inFunction){\r\n\r\n                    /*\r\n                     * operator (outside function)\r\n                     *  : '/' S* | ',' S* | /( empty )/\r\n                     * operator (inside function)\r\n                     *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/\r\n                     *  ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        token       = null;\r\n\r\n                    if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||\r\n                        (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))){\r\n                        token =  tokenStream.token();\r\n                        this._readWhitespace();\r\n                    }\r\n                    return token ? PropertyValuePart.fromToken(token) : null;\r\n\r\n                },\r\n\r\n                _combinator: function(){\r\n\r\n                    /*\r\n                     * combinator\r\n                     *  : PLUS S* | GREATER S* | TILDE S* | S+\r\n                     *  ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        value       = null,\r\n                        token;\r\n\r\n                    if(tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])){\r\n                        token = tokenStream.token();\r\n                        value = new Combinator(token.value, token.startLine, token.startCol);\r\n                        this._readWhitespace();\r\n                    }\r\n\r\n                    return value;\r\n                },\r\n\r\n                _unary_operator: function(){\r\n\r\n                    /*\r\n                     * unary_operator\r\n                     *  : '-' | '+'\r\n                     *  ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream;\r\n\r\n                    if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])){\r\n                        return tokenStream.token().value;\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                },\r\n\r\n                _property: function(){\r\n\r\n                    /*\r\n                     * property\r\n                     *   : IDENT S*\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        value       = null,\r\n                        hack        = null,\r\n                        tokenValue,\r\n                        token,\r\n                        line,\r\n                        col;\r\n\r\n                    //check for star hack - throws error if not allowed\r\n                    if (tokenStream.peek() == Tokens.STAR && this.options.starHack){\r\n                        tokenStream.get();\r\n                        token = tokenStream.token();\r\n                        hack = token.value;\r\n                        line = token.startLine;\r\n                        col = token.startCol;\r\n                    }\r\n\r\n                    if(tokenStream.match(Tokens.IDENT)){\r\n                        token = tokenStream.token();\r\n                        tokenValue = token.value;\r\n\r\n                        //check for underscore hack - no error if not allowed because it's valid CSS syntax\r\n                        if (tokenValue.charAt(0) == \"_\" && this.options.underscoreHack){\r\n                            hack = \"_\";\r\n                            tokenValue = tokenValue.substring(1);\r\n                        }\r\n\r\n                        value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));\r\n                        this._readWhitespace();\r\n                    }\r\n\r\n                    return value;\r\n                },\r\n\r\n                //Augmented with CSS3 Selectors\r\n                _ruleset: function(){\r\n                    /*\r\n                     * ruleset\r\n                     *   : selectors_group\r\n                     *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        tt,\r\n                        selectors;\r\n\r\n\r\n                    /*\r\n                     * Error Recovery: If even a single selector fails to parse,\r\n                     * then the entire ruleset should be thrown away.\r\n                     */\r\n                    try {\r\n                        selectors = this._selectors_group();\r\n                    } catch (ex){\r\n                        if (ex instanceof SyntaxError && !this.options.strict){\r\n\r\n                            //fire error event\r\n                            this.fire({\r\n                                type:       \"error\",\r\n                                error:      ex,\r\n                                message:    ex.message,\r\n                                line:       ex.line,\r\n                                col:        ex.col\r\n                            });\r\n\r\n                            //skip over everything until closing brace\r\n                            tt = tokenStream.advance([Tokens.RBRACE]);\r\n                            if (tt == Tokens.RBRACE){\r\n                                //if there's a right brace, the rule is finished so don't do anything\r\n                            } else {\r\n                                //otherwise, rethrow the error because it wasn't handled properly\r\n                                throw ex;\r\n                            }\r\n\r\n                        } else {\r\n                            //not a syntax error, rethrow it\r\n                            throw ex;\r\n                        }\r\n\r\n                        //trigger parser to continue\r\n                        return true;\r\n                    }\r\n\r\n                    //if it got here, all selectors parsed\r\n                    if (selectors){\r\n\r\n                        this.fire({\r\n                            type:       \"startrule\",\r\n                            selectors:  selectors,\r\n                            line:       selectors[0].line,\r\n                            col:        selectors[0].col\r\n                        });\r\n\r\n                        this._readDeclarations(true);\r\n\r\n                        this.fire({\r\n                            type:       \"endrule\",\r\n                            selectors:  selectors,\r\n                            line:       selectors[0].line,\r\n                            col:        selectors[0].col\r\n                        });\r\n\r\n                    }\r\n\r\n                    return selectors;\r\n\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _selectors_group: function(){\r\n\r\n                    /*\r\n                     * selectors_group\r\n                     *   : selector [ COMMA S* selector ]*\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        selectors   = [],\r\n                        selector;\r\n\r\n                    selector = this._selector();\r\n                    if (selector !== null){\r\n\r\n                        selectors.push(selector);\r\n                        while(tokenStream.match(Tokens.COMMA)){\r\n                            this._readWhitespace();\r\n                            selector = this._selector();\r\n                            if (selector !== null){\r\n                                selectors.push(selector);\r\n                            } else {\r\n                                this._unexpectedToken(tokenStream.LT(1));\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return selectors.length ? selectors : null;\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _selector: function(){\r\n                    /*\r\n                     * selector\r\n                     *   : simple_selector_sequence [ combinator simple_selector_sequence ]*\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        selector    = [],\r\n                        nextSelector = null,\r\n                        combinator  = null,\r\n                        ws          = null;\r\n\r\n                    //if there's no simple selector, then there's no selector\r\n                    nextSelector = this._simple_selector_sequence();\r\n                    if (nextSelector === null){\r\n                        return null;\r\n                    }\r\n\r\n                    selector.push(nextSelector);\r\n\r\n                    do {\r\n\r\n                        //look for a combinator\r\n                        combinator = this._combinator();\r\n\r\n                        if (combinator !== null){\r\n                            selector.push(combinator);\r\n                            nextSelector = this._simple_selector_sequence();\r\n\r\n                            //there must be a next selector\r\n                            if (nextSelector === null){\r\n                                this._unexpectedToken(tokenStream.LT(1));\r\n                            } else {\r\n\r\n                                //nextSelector is an instance of SelectorPart\r\n                                selector.push(nextSelector);\r\n                            }\r\n                        } else {\r\n\r\n                            //if there's not whitespace, we're done\r\n                            if (this._readWhitespace()){\r\n\r\n                                //add whitespace separator\r\n                                ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);\r\n\r\n                                //combinator is not required\r\n                                combinator = this._combinator();\r\n\r\n                                //selector is required if there's a combinator\r\n                                nextSelector = this._simple_selector_sequence();\r\n                                if (nextSelector === null){\r\n                                    if (combinator !== null){\r\n                                        this._unexpectedToken(tokenStream.LT(1));\r\n                                    }\r\n                                } else {\r\n\r\n                                    if (combinator !== null){\r\n                                        selector.push(combinator);\r\n                                    } else {\r\n                                        selector.push(ws);\r\n                                    }\r\n\r\n                                    selector.push(nextSelector);\r\n                                }\r\n                            } else {\r\n                                break;\r\n                            }\r\n\r\n                        }\r\n                    } while(true);\r\n\r\n                    return new Selector(selector, selector[0].line, selector[0].col);\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _simple_selector_sequence: function(){\r\n                    /*\r\n                     * simple_selector_sequence\r\n                     *   : [ type_selector | universal ]\r\n                     *     [ HASH | class | attrib | pseudo | negation ]*\r\n                     *   | [ HASH | class | attrib | pseudo | negation ]+\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n\r\n                        //parts of a simple selector\r\n                        elementName = null,\r\n                        modifiers   = [],\r\n\r\n                        //complete selector text\r\n                        selectorText= \"\",\r\n\r\n                        //the different parts after the element name to search for\r\n                        components  = [\r\n                            //HASH\r\n                            function(){\r\n                                return tokenStream.match(Tokens.HASH) ?\r\n                                        new SelectorSubPart(tokenStream.token().value, \"id\", tokenStream.token().startLine, tokenStream.token().startCol) :\r\n                                        null;\r\n                            },\r\n                            this._class,\r\n                            this._attrib,\r\n                            this._pseudo,\r\n                            this._negation\r\n                        ],\r\n                        i           = 0,\r\n                        len         = components.length,\r\n                        component   = null,\r\n                        found       = false,\r\n                        line,\r\n                        col;\r\n\r\n\r\n                    //get starting line and column for the selector\r\n                    line = tokenStream.LT(1).startLine;\r\n                    col = tokenStream.LT(1).startCol;\r\n\r\n                    elementName = this._type_selector();\r\n                    if (!elementName){\r\n                        elementName = this._universal();\r\n                    }\r\n\r\n                    if (elementName !== null){\r\n                        selectorText += elementName;\r\n                    }\r\n\r\n                    while(true){\r\n\r\n                        //whitespace means we're done\r\n                        if (tokenStream.peek() === Tokens.S){\r\n                            break;\r\n                        }\r\n\r\n                        //check for each component\r\n                        while(i < len && component === null){\r\n                            component = components[i++].call(this);\r\n                        }\r\n\r\n                        if (component === null){\r\n\r\n                            //we don't have a selector\r\n                            if (selectorText === \"\"){\r\n                                return null;\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        } else {\r\n                            i = 0;\r\n                            modifiers.push(component);\r\n                            selectorText += component.toString();\r\n                            component = null;\r\n                        }\r\n                    }\r\n\r\n\r\n                    return selectorText !== \"\" ?\r\n                            new SelectorPart(elementName, modifiers, selectorText, line, col) :\r\n                            null;\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _type_selector: function(){\r\n                    /*\r\n                     * type_selector\r\n                     *   : [ namespace_prefix ]? element_name\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        ns          = this._namespace_prefix(),\r\n                        elementName = this._element_name();\r\n\r\n                    if (!elementName){\r\n                        /*\r\n                         * Need to back out the namespace that was read due to both\r\n                         * type_selector and universal reading namespace_prefix\r\n                         * first. Kind of hacky, but only way I can figure out\r\n                         * right now how to not change the grammar.\r\n                         */\r\n                        if (ns){\r\n                            tokenStream.unget();\r\n                            if (ns.length > 1){\r\n                                tokenStream.unget();\r\n                            }\r\n                        }\r\n\r\n                        return null;\r\n                    } else {\r\n                        if (ns){\r\n                            elementName.text = ns + elementName.text;\r\n                            elementName.col -= ns.length;\r\n                        }\r\n                        return elementName;\r\n                    }\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _class: function(){\r\n                    /*\r\n                     * class\r\n                     *   : '.' IDENT\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        token;\r\n\r\n                    if (tokenStream.match(Tokens.DOT)){\r\n                        tokenStream.mustMatch(Tokens.IDENT);\r\n                        token = tokenStream.token();\r\n                        return new SelectorSubPart(\".\" + token.value, \"class\", token.startLine, token.startCol - 1);\r\n                    } else {\r\n                        return null;\r\n                    }\r\n\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _element_name: function(){\r\n                    /*\r\n                     * element_name\r\n                     *   : IDENT\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        token;\r\n\r\n                    if (tokenStream.match(Tokens.IDENT)){\r\n                        token = tokenStream.token();\r\n                        return new SelectorSubPart(token.value, \"elementName\", token.startLine, token.startCol);\r\n\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _namespace_prefix: function(){\r\n                    /*\r\n                     * namespace_prefix\r\n                     *   : [ IDENT | '*' ]? '|'\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        value       = \"\";\r\n\r\n                    //verify that this is a namespace prefix\r\n                    if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE){\r\n\r\n                        if(tokenStream.match([Tokens.IDENT, Tokens.STAR])){\r\n                            value += tokenStream.token().value;\r\n                        }\r\n\r\n                        tokenStream.mustMatch(Tokens.PIPE);\r\n                        value += \"|\";\r\n\r\n                    }\r\n\r\n                    return value.length ? value : null;\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _universal: function(){\r\n                    /*\r\n                     * universal\r\n                     *   : [ namespace_prefix ]? '*'\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        value       = \"\",\r\n                        ns;\r\n\r\n                    ns = this._namespace_prefix();\r\n                    if(ns){\r\n                        value += ns;\r\n                    }\r\n\r\n                    if(tokenStream.match(Tokens.STAR)){\r\n                        value += \"*\";\r\n                    }\r\n\r\n                    return value.length ? value : null;\r\n\r\n               },\r\n\r\n                //CSS3 Selectors\r\n                _attrib: function(){\r\n                    /*\r\n                     * attrib\r\n                     *   : '[' S* [ namespace_prefix ]? IDENT S*\r\n                     *         [ [ PREFIXMATCH |\r\n                     *             SUFFIXMATCH |\r\n                     *             SUBSTRINGMATCH |\r\n                     *             '=' |\r\n                     *             INCLUDES |\r\n                     *             DASHMATCH ] S* [ IDENT | STRING ] S*\r\n                     *         ]? ']'\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        value       = null,\r\n                        ns,\r\n                        token;\r\n\r\n                    if (tokenStream.match(Tokens.LBRACKET)){\r\n                        token = tokenStream.token();\r\n                        value = token.value;\r\n                        value += this._readWhitespace();\r\n\r\n                        ns = this._namespace_prefix();\r\n\r\n                        if (ns){\r\n                            value += ns;\r\n                        }\r\n\r\n                        tokenStream.mustMatch(Tokens.IDENT);\r\n                        value += tokenStream.token().value;\r\n                        value += this._readWhitespace();\r\n\r\n                        if(tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,\r\n                                Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])){\r\n\r\n                            value += tokenStream.token().value;\r\n                            value += this._readWhitespace();\r\n\r\n                            tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);\r\n                            value += tokenStream.token().value;\r\n                            value += this._readWhitespace();\r\n                        }\r\n\r\n                        tokenStream.mustMatch(Tokens.RBRACKET);\r\n\r\n                        return new SelectorSubPart(value + \"]\", \"attribute\", token.startLine, token.startCol);\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _pseudo: function(){\r\n\r\n                    /*\r\n                     * pseudo\r\n                     *   : ':' ':'? [ IDENT | functional_pseudo ]\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        pseudo      = null,\r\n                        colons      = \":\",\r\n                        line,\r\n                        col;\r\n\r\n                    if (tokenStream.match(Tokens.COLON)){\r\n\r\n                        if (tokenStream.match(Tokens.COLON)){\r\n                            colons += \":\";\r\n                        }\r\n\r\n                        if (tokenStream.match(Tokens.IDENT)){\r\n                            pseudo = tokenStream.token().value;\r\n                            line = tokenStream.token().startLine;\r\n                            col = tokenStream.token().startCol - colons.length;\r\n                        } else if (tokenStream.peek() == Tokens.FUNCTION){\r\n                            line = tokenStream.LT(1).startLine;\r\n                            col = tokenStream.LT(1).startCol - colons.length;\r\n                            pseudo = this._functional_pseudo();\r\n                        }\r\n\r\n                        if (pseudo){\r\n                            pseudo = new SelectorSubPart(colons + pseudo, \"pseudo\", line, col);\r\n                        }\r\n                    }\r\n\r\n                    return pseudo;\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _functional_pseudo: function(){\r\n                    /*\r\n                     * functional_pseudo\r\n                     *   : FUNCTION S* expression ')'\r\n                     *   ;\r\n                    */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        value = null;\r\n\r\n                    if(tokenStream.match(Tokens.FUNCTION)){\r\n                        value = tokenStream.token().value;\r\n                        value += this._readWhitespace();\r\n                        value += this._expression();\r\n                        tokenStream.mustMatch(Tokens.RPAREN);\r\n                        value += \")\";\r\n                    }\r\n\r\n                    return value;\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _expression: function(){\r\n                    /*\r\n                     * expression\r\n                     *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        value       = \"\";\r\n\r\n                    while(tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,\r\n                            Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,\r\n                            Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,\r\n                            Tokens.RESOLUTION, Tokens.SLASH])){\r\n\r\n                        value += tokenStream.token().value;\r\n                        value += this._readWhitespace();\r\n                    }\r\n\r\n                    return value.length ? value : null;\r\n\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _negation: function(){\r\n                    /*\r\n                     * negation\r\n                     *   : NOT S* negation_arg S* ')'\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        line,\r\n                        col,\r\n                        value       = \"\",\r\n                        arg,\r\n                        subpart     = null;\r\n\r\n                    if (tokenStream.match(Tokens.NOT)){\r\n                        value = tokenStream.token().value;\r\n                        line = tokenStream.token().startLine;\r\n                        col = tokenStream.token().startCol;\r\n                        value += this._readWhitespace();\r\n                        arg = this._negation_arg();\r\n                        value += arg;\r\n                        value += this._readWhitespace();\r\n                        tokenStream.match(Tokens.RPAREN);\r\n                        value += tokenStream.token().value;\r\n\r\n                        subpart = new SelectorSubPart(value, \"not\", line, col);\r\n                        subpart.args.push(arg);\r\n                    }\r\n\r\n                    return subpart;\r\n                },\r\n\r\n                //CSS3 Selectors\r\n                _negation_arg: function(){\r\n                    /*\r\n                     * negation_arg\r\n                     *   : type_selector | universal | HASH | class | attrib | pseudo\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        args        = [\r\n                            this._type_selector,\r\n                            this._universal,\r\n                            function(){\r\n                                return tokenStream.match(Tokens.HASH) ?\r\n                                        new SelectorSubPart(tokenStream.token().value, \"id\", tokenStream.token().startLine, tokenStream.token().startCol) :\r\n                                        null;\r\n                            },\r\n                            this._class,\r\n                            this._attrib,\r\n                            this._pseudo\r\n                        ],\r\n                        arg         = null,\r\n                        i           = 0,\r\n                        len         = args.length,\r\n                        elementName,\r\n                        line,\r\n                        col,\r\n                        part;\r\n\r\n                    line = tokenStream.LT(1).startLine;\r\n                    col = tokenStream.LT(1).startCol;\r\n\r\n                    while(i < len && arg === null){\r\n\r\n                        arg = args[i].call(this);\r\n                        i++;\r\n                    }\r\n\r\n                    //must be a negation arg\r\n                    if (arg === null){\r\n                        this._unexpectedToken(tokenStream.LT(1));\r\n                    }\r\n\r\n                    //it's an element name\r\n                    if (arg.type == \"elementName\"){\r\n                        part = new SelectorPart(arg, [], arg.toString(), line, col);\r\n                    } else {\r\n                        part = new SelectorPart(null, [arg], arg.toString(), line, col);\r\n                    }\r\n\r\n                    return part;\r\n                },\r\n\r\n                _declaration: function(){\r\n\r\n                    /*\r\n                     * declaration\r\n                     *   : property ':' S* expr prio?\r\n                     *   | /( empty )/\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        property    = null,\r\n                        expr        = null,\r\n                        prio        = null,\r\n                        error       = null,\r\n                        invalid     = null,\r\n                        propertyName= \"\";\r\n\r\n                    property = this._property();\r\n                    if (property !== null){\r\n\r\n                        tokenStream.mustMatch(Tokens.COLON);\r\n                        this._readWhitespace();\r\n\r\n                        expr = this._expr();\r\n\r\n                        //if there's no parts for the value, it's an error\r\n                        if (!expr || expr.length === 0){\r\n                            this._unexpectedToken(tokenStream.LT(1));\r\n                        }\r\n\r\n                        prio = this._prio();\r\n\r\n                        /*\r\n                         * If hacks should be allowed, then only check the root\r\n                         * property. If hacks should not be allowed, treat\r\n                         * _property or *property as invalid properties.\r\n                         */\r\n                        propertyName = property.toString();\r\n                        if (this.options.starHack && property.hack == \"*\" ||\r\n                                this.options.underscoreHack && property.hack == \"_\") {\r\n\r\n                            propertyName = property.text;\r\n                        }\r\n\r\n                        try {\r\n                            this._validateProperty(propertyName, expr);\r\n                        } catch (ex) {\r\n                            invalid = ex;\r\n                        }\r\n\r\n                        this.fire({\r\n                            type:       \"property\",\r\n                            property:   property,\r\n                            value:      expr,\r\n                            important:  prio,\r\n                            line:       property.line,\r\n                            col:        property.col,\r\n                            invalid:    invalid\r\n                        });\r\n\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                },\r\n\r\n                _prio: function(){\r\n                    /*\r\n                     * prio\r\n                     *   : IMPORTANT_SYM S*\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        result      = tokenStream.match(Tokens.IMPORTANT_SYM);\r\n\r\n                    this._readWhitespace();\r\n                    return result;\r\n                },\r\n\r\n                _expr: function(inFunction){\r\n                    /*\r\n                     * expr\r\n                     *   : term [ operator term ]*\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        values      = [],\r\n                        //valueParts    = [],\r\n                        value       = null,\r\n                        operator    = null;\r\n\r\n                    value = this._term();\r\n                    if (value !== null){\r\n\r\n                        values.push(value);\r\n\r\n                        do {\r\n                            operator = this._operator(inFunction);\r\n\r\n                            //if there's an operator, keep building up the value parts\r\n                            if (operator){\r\n                                values.push(operator);\r\n                            } /*else {\r\n                                //if there's not an operator, you have a full value\r\n                                values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));\r\n                                valueParts = [];\r\n                            }*/\r\n\r\n                            value = this._term();\r\n\r\n                            if (value === null){\r\n                                break;\r\n                            } else {\r\n                                values.push(value);\r\n                            }\r\n                        } while(true);\r\n                    }\r\n\r\n                    //cleanup\r\n                    /*if (valueParts.length){\r\n                        values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));\r\n                    }*/\r\n\r\n                    return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;\r\n                },\r\n\r\n                _term: function(){\r\n\r\n                    /*\r\n                     * term\r\n                     *   : unary_operator?\r\n                     *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |\r\n                     *       TIME S* | FREQ S* | function | ie_function ]\r\n                     *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        unary       = null,\r\n                        value       = null,\r\n                        token,\r\n                        line,\r\n                        col;\r\n\r\n                    //returns the operator or null\r\n                    unary = this._unary_operator();\r\n                    if (unary !== null){\r\n                        line = tokenStream.token().startLine;\r\n                        col = tokenStream.token().startCol;\r\n                    }\r\n\r\n                    //exception for IE filters\r\n                    if (tokenStream.peek() == Tokens.IE_FUNCTION && this.options.ieFilters){\r\n\r\n                        value = this._ie_function();\r\n                        if (unary === null){\r\n                            line = tokenStream.token().startLine;\r\n                            col = tokenStream.token().startCol;\r\n                        }\r\n\r\n                    //see if there's a simple match\r\n                    } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,\r\n                            Tokens.ANGLE, Tokens.TIME,\r\n                            Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])){\r\n\r\n                        value = tokenStream.token().value;\r\n                        if (unary === null){\r\n                            line = tokenStream.token().startLine;\r\n                            col = tokenStream.token().startCol;\r\n                        }\r\n                        this._readWhitespace();\r\n                    } else {\r\n\r\n                        //see if it's a color\r\n                        token = this._hexcolor();\r\n                        if (token === null){\r\n\r\n                            //if there's no unary, get the start of the next token for line/col info\r\n                            if (unary === null){\r\n                                line = tokenStream.LT(1).startLine;\r\n                                col = tokenStream.LT(1).startCol;\r\n                            }\r\n\r\n                            //has to be a function\r\n                            if (value === null){\r\n\r\n                                /*\r\n                                 * This checks for alpha(opacity=0) style of IE\r\n                                 * functions. IE_FUNCTION only presents progid: style.\r\n                                 */\r\n                                if (tokenStream.LA(3) == Tokens.EQUALS && this.options.ieFilters){\r\n                                    value = this._ie_function();\r\n                                } else {\r\n                                    value = this._function();\r\n                                }\r\n                            }\r\n\r\n                            /*if (value === null){\r\n                                return null;\r\n                                //throw new Error(\"Expected identifier at line \" + tokenStream.token().startLine + \", character \" +  tokenStream.token().startCol + \".\");\r\n                            }*/\r\n\r\n                        } else {\r\n                            value = token.value;\r\n                            if (unary === null){\r\n                                line = token.startLine;\r\n                                col = token.startCol;\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    return value !== null ?\r\n                            new PropertyValuePart(unary !== null ? unary + value : value, line, col) :\r\n                            null;\r\n\r\n                },\r\n\r\n                _function: function(){\r\n\r\n                    /*\r\n                     * function\r\n                     *   : FUNCTION S* expr ')' S*\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        functionText = null,\r\n                        expr        = null,\r\n                        lt;\r\n\r\n                    if (tokenStream.match(Tokens.FUNCTION)){\r\n                        functionText = tokenStream.token().value;\r\n                        this._readWhitespace();\r\n                        expr = this._expr(true);\r\n                        functionText += expr;\r\n\r\n                        //START: Horrible hack in case it's an IE filter\r\n                        if (this.options.ieFilters && tokenStream.peek() == Tokens.EQUALS){\r\n                            do {\r\n\r\n                                if (this._readWhitespace()){\r\n                                    functionText += tokenStream.token().value;\r\n                                }\r\n\r\n                                //might be second time in the loop\r\n                                if (tokenStream.LA(0) == Tokens.COMMA){\r\n                                    functionText += tokenStream.token().value;\r\n                                }\r\n\r\n                                tokenStream.match(Tokens.IDENT);\r\n                                functionText += tokenStream.token().value;\r\n\r\n                                tokenStream.match(Tokens.EQUALS);\r\n                                functionText += tokenStream.token().value;\r\n\r\n                                //functionText += this._term();\r\n                                lt = tokenStream.peek();\r\n                                while(lt != Tokens.COMMA && lt != Tokens.S && lt != Tokens.RPAREN){\r\n                                    tokenStream.get();\r\n                                    functionText += tokenStream.token().value;\r\n                                    lt = tokenStream.peek();\r\n                                }\r\n                            } while(tokenStream.match([Tokens.COMMA, Tokens.S]));\r\n                        }\r\n\r\n                        //END: Horrible Hack\r\n\r\n                        tokenStream.match(Tokens.RPAREN);\r\n                        functionText += \")\";\r\n                        this._readWhitespace();\r\n                    }\r\n\r\n                    return functionText;\r\n                },\r\n\r\n                _ie_function: function(){\r\n\r\n                    /* (My own extension)\r\n                     * ie_function\r\n                     *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        functionText = null,\r\n                        expr        = null,\r\n                        lt;\r\n\r\n                    //IE function can begin like a regular function, too\r\n                    if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])){\r\n                        functionText = tokenStream.token().value;\r\n\r\n                        do {\r\n\r\n                            if (this._readWhitespace()){\r\n                                functionText += tokenStream.token().value;\r\n                            }\r\n\r\n                            //might be second time in the loop\r\n                            if (tokenStream.LA(0) == Tokens.COMMA){\r\n                                functionText += tokenStream.token().value;\r\n                            }\r\n\r\n                            tokenStream.match(Tokens.IDENT);\r\n                            functionText += tokenStream.token().value;\r\n\r\n                            tokenStream.match(Tokens.EQUALS);\r\n                            functionText += tokenStream.token().value;\r\n\r\n                            //functionText += this._term();\r\n                            lt = tokenStream.peek();\r\n                            while(lt != Tokens.COMMA && lt != Tokens.S && lt != Tokens.RPAREN){\r\n                                tokenStream.get();\r\n                                functionText += tokenStream.token().value;\r\n                                lt = tokenStream.peek();\r\n                            }\r\n                        } while(tokenStream.match([Tokens.COMMA, Tokens.S]));\r\n\r\n                        tokenStream.match(Tokens.RPAREN);\r\n                        functionText += \")\";\r\n                        this._readWhitespace();\r\n                    }\r\n\r\n                    return functionText;\r\n                },\r\n\r\n                _hexcolor: function(){\r\n                    /*\r\n                     * There is a constraint on the color that it must\r\n                     * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])\r\n                     * after the \"#\"; e.g., \"#000\" is OK, but \"#abcd\" is not.\r\n                     *\r\n                     * hexcolor\r\n                     *   : HASH S*\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        token = null,\r\n                        color;\r\n\r\n                    if(tokenStream.match(Tokens.HASH)){\r\n\r\n                        //need to do some validation here\r\n\r\n                        token = tokenStream.token();\r\n                        color = token.value;\r\n                        if (!/#[a-f0-9]{3,6}/i.test(color)){\r\n                            throw new SyntaxError(\"Expected a hex color but found '\" + color + \"' at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\r\n                        }\r\n                        this._readWhitespace();\r\n                    }\r\n\r\n                    return token;\r\n                },\r\n\r\n                //-----------------------------------------------------------------\r\n                // Animations methods\r\n                //-----------------------------------------------------------------\r\n\r\n                _keyframes: function(){\r\n\r\n                    /*\r\n                     * keyframes:\r\n                     *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        token,\r\n                        tt,\r\n                        name,\r\n                        prefix = \"\";\r\n\r\n                    tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);\r\n                    token = tokenStream.token();\r\n                    if (/^@\\-([^\\-]+)\\-/.test(token.value)) {\r\n                        prefix = RegExp.$1;\r\n                    }\r\n\r\n                    this._readWhitespace();\r\n                    name = this._keyframe_name();\r\n\r\n                    this._readWhitespace();\r\n                    tokenStream.mustMatch(Tokens.LBRACE);\r\n\r\n                    this.fire({\r\n                        type:   \"startkeyframes\",\r\n                        name:   name,\r\n                        prefix: prefix,\r\n                        line:   token.startLine,\r\n                        col:    token.startCol\r\n                    });\r\n\r\n                    this._readWhitespace();\r\n                    tt = tokenStream.peek();\r\n\r\n                    //check for key\r\n                    while(tt == Tokens.IDENT || tt == Tokens.PERCENTAGE) {\r\n                        this._keyframe_rule();\r\n                        this._readWhitespace();\r\n                        tt = tokenStream.peek();\r\n                    }\r\n\r\n                    this.fire({\r\n                        type:   \"endkeyframes\",\r\n                        name:   name,\r\n                        prefix: prefix,\r\n                        line:   token.startLine,\r\n                        col:    token.startCol\r\n                    });\r\n\r\n                    this._readWhitespace();\r\n                    tokenStream.mustMatch(Tokens.RBRACE);\r\n\r\n                },\r\n\r\n                _keyframe_name: function(){\r\n\r\n                    /*\r\n                     * keyframe_name:\r\n                     *   : IDENT\r\n                     *   | STRING\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        token;\r\n\r\n                    tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);\r\n                    return SyntaxUnit.fromToken(tokenStream.token());\r\n                },\r\n\r\n                _keyframe_rule: function(){\r\n\r\n                    /*\r\n                     * keyframe_rule:\r\n                     *   : key_list S*\r\n                     *     '{' S* declaration [ ';' S* declaration ]* '}' S*\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        token,\r\n                        keyList = this._key_list();\r\n\r\n                    this.fire({\r\n                        type:   \"startkeyframerule\",\r\n                        keys:   keyList,\r\n                        line:   keyList[0].line,\r\n                        col:    keyList[0].col\r\n                    });\r\n\r\n                    this._readDeclarations(true);\r\n\r\n                    this.fire({\r\n                        type:   \"endkeyframerule\",\r\n                        keys:   keyList,\r\n                        line:   keyList[0].line,\r\n                        col:    keyList[0].col\r\n                    });\r\n\r\n                },\r\n\r\n                _key_list: function(){\r\n\r\n                    /*\r\n                     * key_list:\r\n                     *   : key [ S* ',' S* key]*\r\n                     *   ;\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        token,\r\n                        key,\r\n                        keyList = [];\r\n\r\n                    //must be least one key\r\n                    keyList.push(this._key());\r\n\r\n                    this._readWhitespace();\r\n\r\n                    while(tokenStream.match(Tokens.COMMA)){\r\n                        this._readWhitespace();\r\n                        keyList.push(this._key());\r\n                        this._readWhitespace();\r\n                    }\r\n\r\n                    return keyList;\r\n                },\r\n\r\n                _key: function(){\r\n                    /*\r\n                     * There is a restriction that IDENT can be only \"from\" or \"to\".\r\n                     *\r\n                     * key\r\n                     *   : PERCENTAGE\r\n                     *   | IDENT\r\n                     *   ;\r\n                     */\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        token;\r\n\r\n                    if (tokenStream.match(Tokens.PERCENTAGE)){\r\n                        return SyntaxUnit.fromToken(tokenStream.token());\r\n                    } else if (tokenStream.match(Tokens.IDENT)){\r\n                        token = tokenStream.token();\r\n\r\n                        if (/from|to/i.test(token.value)){\r\n                            return SyntaxUnit.fromToken(token);\r\n                        }\r\n\r\n                        tokenStream.unget();\r\n                    }\r\n\r\n                    //if it gets here, there wasn't a valid token, so time to explode\r\n                    this._unexpectedToken(tokenStream.LT(1));\r\n                },\r\n\r\n                //-----------------------------------------------------------------\r\n                // Helper methods\r\n                //-----------------------------------------------------------------\r\n\r\n                /**\r\n                 * Not part of CSS grammar, but useful for skipping over\r\n                 * combination of white space and HTML-style comments.\r\n                 * @return {void}\r\n                 * @method _skipCruft\r\n                 * @private\r\n                 */\r\n                _skipCruft: function(){\r\n                    while(this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])){\r\n                        //noop\r\n                    }\r\n                },\r\n\r\n                /**\r\n                 * Not part of CSS grammar, but this pattern occurs frequently\r\n                 * in the official CSS grammar. Split out here to eliminate\r\n                 * duplicate code.\r\n                 * @param {Boolean} checkStart Indicates if the rule should check\r\n                 *      for the left brace at the beginning.\r\n                 * @param {Boolean} readMargins Indicates if the rule should check\r\n                 *      for margin patterns.\r\n                 * @return {void}\r\n                 * @method _readDeclarations\r\n                 * @private\r\n                 */\r\n                _readDeclarations: function(checkStart, readMargins){\r\n                    /*\r\n                     * Reads the pattern\r\n                     * S* '{' S* declaration [ ';' S* declaration ]* '}' S*\r\n                     * or\r\n                     * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*\r\n                     * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.\r\n                     * A semicolon is only necessary following a declaration is there's another declaration\r\n                     * or margin afterwards.\r\n                     */\r\n                    var tokenStream = this._tokenStream,\r\n                        tt;\r\n\r\n\r\n                    this._readWhitespace();\r\n\r\n                    if (checkStart){\r\n                        tokenStream.mustMatch(Tokens.LBRACE);\r\n                    }\r\n\r\n                    this._readWhitespace();\r\n\r\n                    try {\r\n\r\n                        while(true){\r\n\r\n                            if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())){\r\n                                //noop\r\n                            } else if (this._declaration()){\r\n                                if (!tokenStream.match(Tokens.SEMICOLON)){\r\n                                    break;\r\n                                }\r\n                            } else {\r\n                                break;\r\n                            }\r\n\r\n                            //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){\r\n                            //    break;\r\n                            //}\r\n                            this._readWhitespace();\r\n                        }\r\n\r\n                        tokenStream.mustMatch(Tokens.RBRACE);\r\n                        this._readWhitespace();\r\n\r\n                    } catch (ex) {\r\n                        if (ex instanceof SyntaxError && !this.options.strict){\r\n\r\n                            //fire error event\r\n                            this.fire({\r\n                                type:       \"error\",\r\n                                error:      ex,\r\n                                message:    ex.message,\r\n                                line:       ex.line,\r\n                                col:        ex.col\r\n                            });\r\n\r\n                            //see if there's another declaration\r\n                            tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);\r\n                            if (tt == Tokens.SEMICOLON){\r\n                                //if there's a semicolon, then there might be another declaration\r\n                                this._readDeclarations(false, readMargins);\r\n                            } else if (tt != Tokens.RBRACE){\r\n                                //if there's a right brace, the rule is finished so don't do anything\r\n                                //otherwise, rethrow the error because it wasn't handled properly\r\n                                throw ex;\r\n                            }\r\n\r\n                        } else {\r\n                            //not a syntax error, rethrow it\r\n                            throw ex;\r\n                        }\r\n                    }\r\n\r\n                },\r\n\r\n                /**\r\n                 * In some cases, you can end up with two white space tokens in a\r\n                 * row. Instead of making a change in every function that looks for\r\n                 * white space, this function is used to match as much white space\r\n                 * as necessary.\r\n                 * @method _readWhitespace\r\n                 * @return {String} The white space if found, empty string if not.\r\n                 * @private\r\n                 */\r\n                _readWhitespace: function(){\r\n\r\n                    var tokenStream = this._tokenStream,\r\n                        ws = \"\";\r\n\r\n                    while(tokenStream.match(Tokens.S)){\r\n                        ws += tokenStream.token().value;\r\n                    }\r\n\r\n                    return ws;\r\n                },\r\n\r\n\r\n                /**\r\n                 * Throws an error when an unexpected token is found.\r\n                 * @param {Object} token The token that was found.\r\n                 * @method _unexpectedToken\r\n                 * @return {void}\r\n                 * @private\r\n                 */\r\n                _unexpectedToken: function(token){\r\n                    throw new SyntaxError(\"Unexpected token '\" + token.value + \"' at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\r\n                },\r\n\r\n                /**\r\n                 * Helper method used for parsing subparts of a style sheet.\r\n                 * @return {void}\r\n                 * @method _verifyEnd\r\n                 * @private\r\n                 */\r\n                _verifyEnd: function(){\r\n                    if (this._tokenStream.LA(1) != Tokens.EOF){\r\n                        this._unexpectedToken(this._tokenStream.LT(1));\r\n                    }\r\n                },\r\n\r\n                //-----------------------------------------------------------------\r\n                // Validation methods\r\n                //-----------------------------------------------------------------\r\n                _validateProperty: function(property, value){\r\n                    Validation.validate(property, value);\r\n                },\r\n\r\n                //-----------------------------------------------------------------\r\n                // Parsing methods\r\n                //-----------------------------------------------------------------\r\n\r\n                parse: function(input){\r\n                    this._tokenStream = new TokenStream(input, Tokens);\r\n                    this._stylesheet();\r\n                },\r\n\r\n                parseStyleSheet: function(input){\r\n                    //just passthrough\r\n                    return this.parse(input);\r\n                },\r\n\r\n                parseMediaQuery: function(input){\r\n                    this._tokenStream = new TokenStream(input, Tokens);\r\n                    var result = this._media_query();\r\n\r\n                    //if there's anything more, then it's an invalid selector\r\n                    this._verifyEnd();\r\n\r\n                    //otherwise return result\r\n                    return result;\r\n                },\r\n\r\n                /**\r\n                 * Parses a property value (everything after the semicolon).\r\n                 * @return {parserlib.css.PropertyValue} The property value.\r\n                 * @throws parserlib.util.SyntaxError If an unexpected token is found.\r\n                 * @method parserPropertyValue\r\n                 */\r\n                parsePropertyValue: function(input){\r\n\r\n                    this._tokenStream = new TokenStream(input, Tokens);\r\n                    this._readWhitespace();\r\n\r\n                    var result = this._expr();\r\n\r\n                    //okay to have a trailing white space\r\n                    this._readWhitespace();\r\n\r\n                    //if there's anything more, then it's an invalid selector\r\n                    this._verifyEnd();\r\n\r\n                    //otherwise return result\r\n                    return result;\r\n                },\r\n\r\n                /**\r\n                 * Parses a complete CSS rule, including selectors and\r\n                 * properties.\r\n                 * @param {String} input The text to parser.\r\n                 * @return {Boolean} True if the parse completed successfully, false if not.\r\n                 * @method parseRule\r\n                 */\r\n                parseRule: function(input){\r\n                    this._tokenStream = new TokenStream(input, Tokens);\r\n\r\n                    //skip any leading white space\r\n                    this._readWhitespace();\r\n\r\n                    var result = this._ruleset();\r\n\r\n                    //skip any trailing white space\r\n                    this._readWhitespace();\r\n\r\n                    //if there's anything more, then it's an invalid selector\r\n                    this._verifyEnd();\r\n\r\n                    //otherwise return result\r\n                    return result;\r\n                },\r\n\r\n                /**\r\n                 * Parses a single CSS selector (no comma)\r\n                 * @param {String} input The text to parse as a CSS selector.\r\n                 * @return {Selector} An object representing the selector.\r\n                 * @throws parserlib.util.SyntaxError If an unexpected token is found.\r\n                 * @method parseSelector\r\n                 */\r\n                parseSelector: function(input){\r\n\r\n                    this._tokenStream = new TokenStream(input, Tokens);\r\n\r\n                    //skip any leading white space\r\n                    this._readWhitespace();\r\n\r\n                    var result = this._selector();\r\n\r\n                    //skip any trailing white space\r\n                    this._readWhitespace();\r\n\r\n                    //if there's anything more, then it's an invalid selector\r\n                    this._verifyEnd();\r\n\r\n                    //otherwise return result\r\n                    return result;\r\n                },\r\n\r\n                /**\r\n                 * Parses an HTML style attribute: a set of CSS declarations\r\n                 * separated by semicolons.\r\n                 * @param {String} input The text to parse as a style attribute\r\n                 * @return {void}\r\n                 * @method parseStyleAttribute\r\n                 */\r\n                parseStyleAttribute: function(input){\r\n                    input += \"}\"; // for error recovery in _readDeclarations()\r\n                    this._tokenStream = new TokenStream(input, Tokens);\r\n                    this._readDeclarations();\r\n                }\r\n            };\r\n\r\n        //copy over onto prototype\r\n        for (prop in additions){\r\n            if (additions.hasOwnProperty(prop)){\r\n                proto[prop] = additions[prop];\r\n            }\r\n        }\r\n\r\n        return proto;\r\n    }();\r\n\r\n\r\n    /*\r\n    nth\r\n      : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |\r\n             ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*\r\n      ;\r\n    */\r\n\r\n    /*global Validation, ValidationTypes, ValidationError*/\r\n    var Properties = {\r\n\r\n        //A\r\n        \"alignment-adjust\"              : \"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>\",\r\n        \"alignment-baseline\"            : \"baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\r\n        \"animation\"                     : 1,\r\n        \"animation-delay\"               : { multi: \"<time>\", comma: true },\r\n        \"animation-direction\"           : { multi: \"normal | alternate\", comma: true },\r\n        \"animation-duration\"            : { multi: \"<time>\", comma: true },\r\n        \"animation-iteration-count\"     : { multi: \"<number> | infinite\", comma: true },\r\n        \"animation-name\"                : { multi: \"none | <ident>\", comma: true },\r\n        \"animation-play-state\"          : { multi: \"running | paused\", comma: true },\r\n        \"animation-timing-function\"     : 1,\r\n\r\n        //vendor prefixed\r\n        \"-moz-animation-delay\"               : { multi: \"<time>\", comma: true },\r\n        \"-moz-animation-direction\"           : { multi: \"normal | alternate\", comma: true },\r\n        \"-moz-animation-duration\"            : { multi: \"<time>\", comma: true },\r\n        \"-moz-animation-iteration-count\"     : { multi: \"<number> | infinite\", comma: true },\r\n        \"-moz-animation-name\"                : { multi: \"none | <ident>\", comma: true },\r\n        \"-moz-animation-play-state\"          : { multi: \"running | paused\", comma: true },\r\n\r\n        \"-ms-animation-delay\"               : { multi: \"<time>\", comma: true },\r\n        \"-ms-animation-direction\"           : { multi: \"normal | alternate\", comma: true },\r\n        \"-ms-animation-duration\"            : { multi: \"<time>\", comma: true },\r\n        \"-ms-animation-iteration-count\"     : { multi: \"<number> | infinite\", comma: true },\r\n        \"-ms-animation-name\"                : { multi: \"none | <ident>\", comma: true },\r\n        \"-ms-animation-play-state\"          : { multi: \"running | paused\", comma: true },\r\n\r\n        \"-webkit-animation-delay\"               : { multi: \"<time>\", comma: true },\r\n        \"-webkit-animation-direction\"           : { multi: \"normal | alternate\", comma: true },\r\n        \"-webkit-animation-duration\"            : { multi: \"<time>\", comma: true },\r\n        \"-webkit-animation-iteration-count\"     : { multi: \"<number> | infinite\", comma: true },\r\n        \"-webkit-animation-name\"                : { multi: \"none | <ident>\", comma: true },\r\n        \"-webkit-animation-play-state\"          : { multi: \"running | paused\", comma: true },\r\n\r\n        \"-o-animation-delay\"               : { multi: \"<time>\", comma: true },\r\n        \"-o-animation-direction\"           : { multi: \"normal | alternate\", comma: true },\r\n        \"-o-animation-duration\"            : { multi: \"<time>\", comma: true },\r\n        \"-o-animation-iteration-count\"     : { multi: \"<number> | infinite\", comma: true },\r\n        \"-o-animation-name\"                : { multi: \"none | <ident>\", comma: true },\r\n        \"-o-animation-play-state\"          : { multi: \"running | paused\", comma: true },\r\n\r\n        \"appearance\"                    : \"icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit\",\r\n        \"azimuth\"                       : function (expression) {\r\n            var simple      = \"<angle> | leftwards | rightwards | inherit\",\r\n                direction   = \"left-side | far-left | left | center-left | center | center-right | right | far-right | right-side\",\r\n                behind      = false,\r\n                valid       = false,\r\n                part;\r\n\r\n            if (!ValidationTypes.isAny(expression, simple)) {\r\n                if (ValidationTypes.isAny(expression, \"behind\")) {\r\n                    behind = true;\r\n                    valid = true;\r\n                }\r\n\r\n                if (ValidationTypes.isAny(expression, direction)) {\r\n                    valid = true;\r\n                    if (!behind) {\r\n                        ValidationTypes.isAny(expression, \"behind\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (expression.hasNext()) {\r\n                part = expression.next();\r\n                if (valid) {\r\n                    throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n                } else {\r\n                    throw new ValidationError(\"Expected (<'azimuth'>) but found '\" + part + \"'.\", part.line, part.col);\r\n                }\r\n            }\r\n        },\r\n\r\n        //B\r\n        \"backface-visibility\"           : \"visible | hidden\",\r\n        \"background\"                    : 1,\r\n        \"background-attachment\"         : { multi: \"<attachment>\", comma: true },\r\n        \"background-clip\"               : { multi: \"<box>\", comma: true },\r\n        \"background-color\"              : \"<color> | inherit\",\r\n        \"background-image\"              : { multi: \"<bg-image>\", comma: true },\r\n        \"background-origin\"             : { multi: \"<box>\", comma: true },\r\n        \"background-position\"           : { multi: \"<bg-position>\", comma: true },\r\n        \"background-repeat\"             : { multi: \"<repeat-style>\" },\r\n        \"background-size\"               : { multi: \"<bg-size>\", comma: true },\r\n        \"baseline-shift\"                : \"baseline | sub | super | <percentage> | <length>\",\r\n        \"behavior\"                      : 1,\r\n        \"binding\"                       : 1,\r\n        \"bleed\"                         : \"<length>\",\r\n        \"bookmark-label\"                : \"<content> | <attr> | <string>\",\r\n        \"bookmark-level\"                : \"none | <integer>\",\r\n        \"bookmark-state\"                : \"open | closed\",\r\n        \"bookmark-target\"               : \"none | <uri> | <attr>\",\r\n        \"border\"                        : \"<border-width> || <border-style> || <color>\",\r\n        \"border-bottom\"                 : \"<border-width> || <border-style> || <color>\",\r\n        \"border-bottom-color\"           : \"<color> | inherit\",\r\n        \"border-bottom-left-radius\"     :  \"<x-one-radius>\",\r\n        \"border-bottom-right-radius\"    :  \"<x-one-radius>\",\r\n        \"border-bottom-style\"           : \"<border-style>\",\r\n        \"border-bottom-width\"           : \"<border-width>\",\r\n        \"border-collapse\"               : \"collapse | separate | inherit\",\r\n        \"border-color\"                  : { multi: \"<color> | inherit\", max: 4 },\r\n        \"border-image\"                  : 1,\r\n        \"border-image-outset\"           : { multi: \"<length> | <number>\", max: 4 },\r\n        \"border-image-repeat\"           : { multi: \"stretch | repeat | round\", max: 2 },\r\n        \"border-image-slice\"            : function(expression) {\r\n\r\n            var valid   = false,\r\n                numeric = \"<number> | <percentage>\",\r\n                fill    = false,\r\n                count   = 0,\r\n                max     = 4,\r\n                part;\r\n\r\n            if (ValidationTypes.isAny(expression, \"fill\")) {\r\n                fill = true;\r\n                valid = true;\r\n            }\r\n\r\n            while (expression.hasNext() && count < max) {\r\n                valid = ValidationTypes.isAny(expression, numeric);\r\n                if (!valid) {\r\n                    break;\r\n                }\r\n                count++;\r\n            }\r\n\r\n\r\n            if (!fill) {\r\n                ValidationTypes.isAny(expression, \"fill\");\r\n            } else {\r\n                valid = true;\r\n            }\r\n\r\n            if (expression.hasNext()) {\r\n                part = expression.next();\r\n                if (valid) {\r\n                    throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n                } else {\r\n                    throw new ValidationError(\"Expected ([<number> | <percentage>]{1,4} && fill?) but found '\" + part + \"'.\", part.line, part.col);\r\n                }\r\n            }\r\n        },\r\n        \"border-image-source\"           : \"<image> | none\",\r\n        \"border-image-width\"            : { multi: \"<length> | <percentage> | <number> | auto\", max: 4 },\r\n        \"border-left\"                   : \"<border-width> || <border-style> || <color>\",\r\n        \"border-left-color\"             : \"<color> | inherit\",\r\n        \"border-left-style\"             : \"<border-style>\",\r\n        \"border-left-width\"             : \"<border-width>\",\r\n        \"border-radius\"                 : function(expression) {\r\n\r\n            var valid   = false,\r\n                simple = \"<length> | <percentage> | inherit\",\r\n                slash   = false,\r\n                fill    = false,\r\n                count   = 0,\r\n                max     = 8,\r\n                part;\r\n\r\n            while (expression.hasNext() && count < max) {\r\n                valid = ValidationTypes.isAny(expression, simple);\r\n                if (!valid) {\r\n\r\n                    if (expression.peek() == \"/\" && count > 0 && !slash) {\r\n                        slash = true;\r\n                        max = count + 5;\r\n                        expression.next();\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                count++;\r\n            }\r\n\r\n            if (expression.hasNext()) {\r\n                part = expression.next();\r\n                if (valid) {\r\n                    throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n                } else {\r\n                    throw new ValidationError(\"Expected (<'border-radius'>) but found '\" + part + \"'.\", part.line, part.col);\r\n                }\r\n            }\r\n        },\r\n        \"border-right\"                  : \"<border-width> || <border-style> || <color>\",\r\n        \"border-right-color\"            : \"<color> | inherit\",\r\n        \"border-right-style\"            : \"<border-style>\",\r\n        \"border-right-width\"            : \"<border-width>\",\r\n        \"border-spacing\"                : { multi: \"<length> | inherit\", max: 2 },\r\n        \"border-style\"                  : { multi: \"<border-style>\", max: 4 },\r\n        \"border-top\"                    : \"<border-width> || <border-style> || <color>\",\r\n        \"border-top-color\"              : \"<color> | inherit\",\r\n        \"border-top-left-radius\"        : \"<x-one-radius>\",\r\n        \"border-top-right-radius\"       : \"<x-one-radius>\",\r\n        \"border-top-style\"              : \"<border-style>\",\r\n        \"border-top-width\"              : \"<border-width>\",\r\n        \"border-width\"                  : { multi: \"<border-width>\", max: 4 },\r\n        \"bottom\"                        : \"<margin-width> | inherit\",\r\n        \"box-align\"                     : \"start | end | center | baseline | stretch\",        //http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/\r\n        \"box-decoration-break\"          : \"slice |clone\",\r\n        \"box-direction\"                 : \"normal | reverse | inherit\",\r\n        \"box-flex\"                      : \"<number>\",\r\n        \"box-flex-group\"                : \"<integer>\",\r\n        \"box-lines\"                     : \"single | multiple\",\r\n        \"box-ordinal-group\"             : \"<integer>\",\r\n        \"box-orient\"                    : \"horizontal | vertical | inline-axis | block-axis | inherit\",\r\n        \"box-pack\"                      : \"start | end | center | justify\",\r\n        \"box-shadow\"                    : function (expression) {\r\n            var result      = false,\r\n                part;\r\n\r\n            if (!ValidationTypes.isAny(expression, \"none\")) {\r\n                Validation.multiProperty(\"<shadow>\", expression, true, Infinity);\r\n            } else {\r\n                if (expression.hasNext()) {\r\n                    part = expression.next();\r\n                    throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n                }\r\n            }\r\n        },\r\n        \"box-sizing\"                    : \"content-box | border-box | inherit\",\r\n        \"break-after\"                   : \"auto | always | avoid | left | right | page | column | avoid-page | avoid-column\",\r\n        \"break-before\"                  : \"auto | always | avoid | left | right | page | column | avoid-page | avoid-column\",\r\n        \"break-inside\"                  : \"auto | avoid | avoid-page | avoid-column\",\r\n\r\n        //C\r\n        \"caption-side\"                  : \"top | bottom | inherit\",\r\n        \"clear\"                         : \"none | right | left | both | inherit\",\r\n        \"clip\"                          : 1,\r\n        \"color\"                         : \"<color> | inherit\",\r\n        \"color-profile\"                 : 1,\r\n        \"column-count\"                  : \"<integer> | auto\",                      //http://www.w3.org/TR/css3-multicol/\r\n        \"column-fill\"                   : \"auto | balance\",\r\n        \"column-gap\"                    : \"<length> | normal\",\r\n        \"column-rule\"                   : \"<border-width> || <border-style> || <color>\",\r\n        \"column-rule-color\"             : \"<color>\",\r\n        \"column-rule-style\"             : \"<border-style>\",\r\n        \"column-rule-width\"             : \"<border-width>\",\r\n        \"column-span\"                   : \"none | all\",\r\n        \"column-width\"                  : \"<length> | auto\",\r\n        \"columns\"                       : 1,\r\n        \"content\"                       : 1,\r\n        \"counter-increment\"             : 1,\r\n        \"counter-reset\"                 : 1,\r\n        \"crop\"                          : \"<shape> | auto\",\r\n        \"cue\"                           : \"cue-after | cue-before | inherit\",\r\n        \"cue-after\"                     : 1,\r\n        \"cue-before\"                    : 1,\r\n        \"cursor\"                        : 1,\r\n\r\n        //D\r\n        \"direction\"                     : \"ltr | rtl | inherit\",\r\n        \"display\"                       : \"inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | box | inline-box | grid | inline-grid | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box\",\r\n        \"dominant-baseline\"             : 1,\r\n        \"drop-initial-after-adjust\"     : \"central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>\",\r\n        \"drop-initial-after-align\"      : \"baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\r\n        \"drop-initial-before-adjust\"    : \"before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>\",\r\n        \"drop-initial-before-align\"     : \"caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\r\n        \"drop-initial-size\"             : \"auto | line | <length> | <percentage>\",\r\n        \"drop-initial-value\"            : \"initial | <integer>\",\r\n\r\n        //E\r\n        \"elevation\"                     : \"<angle> | below | level | above | higher | lower | inherit\",\r\n        \"empty-cells\"                   : \"show | hide | inherit\",\r\n\r\n        //F\r\n        \"filter\"                        : 1,\r\n        \"fit\"                           : \"fill | hidden | meet | slice\",\r\n        \"fit-position\"                  : 1,\r\n        \"float\"                         : \"left | right | none | inherit\",\r\n        \"float-offset\"                  : 1,\r\n        \"font\"                          : 1,\r\n        \"font-family\"                   : 1,\r\n        \"font-size\"                     : \"<absolute-size> | <relative-size> | <length> | <percentage> | inherit\",\r\n        \"font-size-adjust\"              : \"<number> | none | inherit\",\r\n        \"font-stretch\"                  : \"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit\",\r\n        \"font-style\"                    : \"normal | italic | oblique | inherit\",\r\n        \"font-variant\"                  : \"normal | small-caps | inherit\",\r\n        \"font-weight\"                   : \"normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit\",\r\n\r\n        //G\r\n        \"grid-cell-stacking\"            : \"columns | rows | layer\",\r\n        \"grid-column\"                   : 1,\r\n        \"grid-columns\"                  : 1,\r\n        \"grid-column-align\"             : \"start | end | center | stretch\",\r\n        \"grid-column-sizing\"            : 1,\r\n        \"grid-column-span\"              : \"<integer>\",\r\n        \"grid-flow\"                     : \"none | rows | columns\",\r\n        \"grid-layer\"                    : \"<integer>\",\r\n        \"grid-row\"                      : 1,\r\n        \"grid-rows\"                     : 1,\r\n        \"grid-row-align\"                : \"start | end | center | stretch\",\r\n        \"grid-row-span\"                 : \"<integer>\",\r\n        \"grid-row-sizing\"               : 1,\r\n\r\n        //H\r\n        \"hanging-punctuation\"           : 1,\r\n        \"height\"                        : \"<margin-width> | inherit\",\r\n        \"hyphenate-after\"               : \"<integer> | auto\",\r\n        \"hyphenate-before\"              : \"<integer> | auto\",\r\n        \"hyphenate-character\"           : \"<string> | auto\",\r\n        \"hyphenate-lines\"               : \"no-limit | <integer>\",\r\n        \"hyphenate-resource\"            : 1,\r\n        \"hyphens\"                       : \"none | manual | auto\",\r\n\r\n        //I\r\n        \"icon\"                          : 1,\r\n        \"image-orientation\"             : \"angle | auto\",\r\n        \"image-rendering\"               : 1,\r\n        \"image-resolution\"              : 1,\r\n        \"inline-box-align\"              : \"initial | last | <integer>\",\r\n\r\n        //L\r\n        \"left\"                          : \"<margin-width> | inherit\",\r\n        \"letter-spacing\"                : \"<length> | normal | inherit\",\r\n        \"line-height\"                   : \"<number> | <length> | <percentage> | normal | inherit\",\r\n        \"line-break\"                    : \"auto | loose | normal | strict\",\r\n        \"line-stacking\"                 : 1,\r\n        \"line-stacking-ruby\"            : \"exclude-ruby | include-ruby\",\r\n        \"line-stacking-shift\"           : \"consider-shifts | disregard-shifts\",\r\n        \"line-stacking-strategy\"        : \"inline-line-height | block-line-height | max-height | grid-height\",\r\n        \"list-style\"                    : 1,\r\n        \"list-style-image\"              : \"<uri> | none | inherit\",\r\n        \"list-style-position\"           : \"inside | outside | inherit\",\r\n        \"list-style-type\"               : \"disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit\",\r\n\r\n        //M\r\n        \"margin\"                        : { multi: \"<margin-width> | inherit\", max: 4 },\r\n        \"margin-bottom\"                 : \"<margin-width> | inherit\",\r\n        \"margin-left\"                   : \"<margin-width> | inherit\",\r\n        \"margin-right\"                  : \"<margin-width> | inherit\",\r\n        \"margin-top\"                    : \"<margin-width> | inherit\",\r\n        \"mark\"                          : 1,\r\n        \"mark-after\"                    : 1,\r\n        \"mark-before\"                   : 1,\r\n        \"marks\"                         : 1,\r\n        \"marquee-direction\"             : 1,\r\n        \"marquee-play-count\"            : 1,\r\n        \"marquee-speed\"                 : 1,\r\n        \"marquee-style\"                 : 1,\r\n        \"max-height\"                    : \"<length> | <percentage> | none | inherit\",\r\n        \"max-width\"                     : \"<length> | <percentage> | none | inherit\",\r\n        \"min-height\"                    : \"<length> | <percentage> | inherit\",\r\n        \"min-width\"                     : \"<length> | <percentage> | inherit\",\r\n        \"move-to\"                       : 1,\r\n\r\n        //N\r\n        \"nav-down\"                      : 1,\r\n        \"nav-index\"                     : 1,\r\n        \"nav-left\"                      : 1,\r\n        \"nav-right\"                     : 1,\r\n        \"nav-up\"                        : 1,\r\n\r\n        //O\r\n        \"opacity\"                       : \"<number> | inherit\",\r\n        \"orphans\"                       : \"<integer> | inherit\",\r\n        \"outline\"                       : 1,\r\n        \"outline-color\"                 : \"<color> | invert | inherit\",\r\n        \"outline-offset\"                : 1,\r\n        \"outline-style\"                 : \"<border-style> | inherit\",\r\n        \"outline-width\"                 : \"<border-width> | inherit\",\r\n        \"overflow\"                      : \"visible | hidden | scroll | auto | inherit\",\r\n        \"overflow-style\"                : 1,\r\n        \"overflow-x\"                    : 1,\r\n        \"overflow-y\"                    : 1,\r\n\r\n        //P\r\n        \"padding\"                       : { multi: \"<padding-width> | inherit\", max: 4 },\r\n        \"padding-bottom\"                : \"<padding-width> | inherit\",\r\n        \"padding-left\"                  : \"<padding-width> | inherit\",\r\n        \"padding-right\"                 : \"<padding-width> | inherit\",\r\n        \"padding-top\"                   : \"<padding-width> | inherit\",\r\n        \"page\"                          : 1,\r\n        \"page-break-after\"              : \"auto | always | avoid | left | right | inherit\",\r\n        \"page-break-before\"             : \"auto | always | avoid | left | right | inherit\",\r\n        \"page-break-inside\"             : \"auto | avoid | inherit\",\r\n        \"page-policy\"                   : 1,\r\n        \"pause\"                         : 1,\r\n        \"pause-after\"                   : 1,\r\n        \"pause-before\"                  : 1,\r\n        \"perspective\"                   : 1,\r\n        \"perspective-origin\"            : 1,\r\n        \"phonemes\"                      : 1,\r\n        \"pitch\"                         : 1,\r\n        \"pitch-range\"                   : 1,\r\n        \"play-during\"                   : 1,\r\n        \"pointer-events\"                : \"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit\",\r\n        \"position\"                      : \"static | relative | absolute | fixed | inherit\",\r\n        \"presentation-level\"            : 1,\r\n        \"punctuation-trim\"              : 1,\r\n\r\n        //Q\r\n        \"quotes\"                        : 1,\r\n\r\n        //R\r\n        \"rendering-intent\"              : 1,\r\n        \"resize\"                        : 1,\r\n        \"rest\"                          : 1,\r\n        \"rest-after\"                    : 1,\r\n        \"rest-before\"                   : 1,\r\n        \"richness\"                      : 1,\r\n        \"right\"                         : \"<margin-width> | inherit\",\r\n        \"rotation\"                      : 1,\r\n        \"rotation-point\"                : 1,\r\n        \"ruby-align\"                    : 1,\r\n        \"ruby-overhang\"                 : 1,\r\n        \"ruby-position\"                 : 1,\r\n        \"ruby-span\"                     : 1,\r\n\r\n        //S\r\n        \"size\"                          : 1,\r\n        \"speak\"                         : \"normal | none | spell-out | inherit\",\r\n        \"speak-header\"                  : \"once | always | inherit\",\r\n        \"speak-numeral\"                 : \"digits | continuous | inherit\",\r\n        \"speak-punctuation\"             : \"code | none | inherit\",\r\n        \"speech-rate\"                   : 1,\r\n        \"src\"                           : 1,\r\n        \"stress\"                        : 1,\r\n        \"string-set\"                    : 1,\r\n\r\n        \"table-layout\"                  : \"auto | fixed | inherit\",\r\n        \"tab-size\"                      : \"<integer> | <length>\",\r\n        \"target\"                        : 1,\r\n        \"target-name\"                   : 1,\r\n        \"target-new\"                    : 1,\r\n        \"target-position\"               : 1,\r\n        \"text-align\"                    : \"left | right | center | justify | inherit\" ,\r\n        \"text-align-last\"               : 1,\r\n        \"text-decoration\"               : 1,\r\n        \"text-emphasis\"                 : 1,\r\n        \"text-height\"                   : 1,\r\n        \"text-indent\"                   : \"<length> | <percentage> | inherit\",\r\n        \"text-justify\"                  : \"auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida\",\r\n        \"text-outline\"                  : 1,\r\n        \"text-overflow\"                 : 1,\r\n        \"text-rendering\"                : \"auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit\",\r\n        \"text-shadow\"                   : 1,\r\n        \"text-transform\"                : \"capitalize | uppercase | lowercase | none | inherit\",\r\n        \"text-wrap\"                     : \"normal | none | avoid\",\r\n        \"top\"                           : \"<margin-width> | inherit\",\r\n        \"transform\"                     : 1,\r\n        \"transform-origin\"              : 1,\r\n        \"transform-style\"               : 1,\r\n        \"transition\"                    : 1,\r\n        \"transition-delay\"              : 1,\r\n        \"transition-duration\"           : 1,\r\n        \"transition-property\"           : 1,\r\n        \"transition-timing-function\"    : 1,\r\n\r\n        //U\r\n        \"unicode-bidi\"                  : \"normal | embed | bidi-override | inherit\",\r\n        \"user-modify\"                   : \"read-only | read-write | write-only | inherit\",\r\n        \"user-select\"                   : \"none | text | toggle | element | elements | all | inherit\",\r\n\r\n        //V\r\n        \"vertical-align\"                : \"auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length>\",\r\n        \"visibility\"                    : \"visible | hidden | collapse | inherit\",\r\n        \"voice-balance\"                 : 1,\r\n        \"voice-duration\"                : 1,\r\n        \"voice-family\"                  : 1,\r\n        \"voice-pitch\"                   : 1,\r\n        \"voice-pitch-range\"             : 1,\r\n        \"voice-rate\"                    : 1,\r\n        \"voice-stress\"                  : 1,\r\n        \"voice-volume\"                  : 1,\r\n        \"volume\"                        : 1,\r\n\r\n        //W\r\n        \"white-space\"                   : \"normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap\", //http://perishablepress.com/wrapping-content/\r\n        \"white-space-collapse\"          : 1,\r\n        \"widows\"                        : \"<integer> | inherit\",\r\n        \"width\"                         : \"<length> | <percentage> | auto | inherit\" ,\r\n        \"word-break\"                    : \"normal | keep-all | break-all\",\r\n        \"word-spacing\"                  : \"<length> | normal | inherit\",\r\n        \"word-wrap\"                     : 1,\r\n\r\n        //Z\r\n        \"z-index\"                       : \"<integer> | auto | inherit\",\r\n        \"zoom\"                          : \"<number> | <percentage> | normal\"\r\n    };\r\n\r\n    /*global SyntaxUnit, Parser*/\r\n    /**\r\n     * Represents a selector combinator (whitespace, +, >).\r\n     * @namespace parserlib.css\r\n     * @class PropertyName\r\n     * @extends parserlib.util.SyntaxUnit\r\n     * @constructor\r\n     * @param {String} text The text representation of the unit.\r\n     * @param {String} hack The type of IE hack applied (\"*\", \"_\", or null).\r\n     * @param {int} line The line of text on which the unit resides.\r\n     * @param {int} col The column of text on which the unit resides.\r\n     */\r\n    function PropertyName(text, hack, line, col){\r\n\r\n        SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);\r\n\r\n        /**\r\n         * The type of IE hack applied (\"*\", \"_\", or null).\r\n         * @type String\r\n         * @property hack\r\n         */\r\n        this.hack = hack;\r\n\r\n    }\r\n\r\n    PropertyName.prototype = new SyntaxUnit();\r\n    PropertyName.prototype.constructor = PropertyName;\r\n    PropertyName.prototype.toString = function(){\r\n        return (this.hack ? this.hack : \"\") + this.text;\r\n    };\r\n\r\n    /*global SyntaxUnit, Parser*/\r\n    /**\r\n     * Represents a single part of a CSS property value, meaning that it represents\r\n     * just everything single part between \":\" and \";\". If there are multiple values\r\n     * separated by commas, this type represents just one of the values.\r\n     * @param {String[]} parts An array of value parts making up this value.\r\n     * @param {int} line The line of text on which the unit resides.\r\n     * @param {int} col The column of text on which the unit resides.\r\n     * @namespace parserlib.css\r\n     * @class PropertyValue\r\n     * @extends parserlib.util.SyntaxUnit\r\n     * @constructor\r\n     */\r\n    function PropertyValue(parts, line, col){\r\n\r\n        SyntaxUnit.call(this, parts.join(\" \"), line, col, Parser.PROPERTY_VALUE_TYPE);\r\n\r\n        /**\r\n         * The parts that make up the selector.\r\n         * @type Array\r\n         * @property parts\r\n         */\r\n        this.parts = parts;\r\n\r\n    }\r\n\r\n    PropertyValue.prototype = new SyntaxUnit();\r\n    PropertyValue.prototype.constructor = PropertyValue;\r\n\r\n\r\n    /*global SyntaxUnit, Parser*/\r\n    /**\r\n     * A utility class that allows for easy iteration over the various parts of a\r\n     * property value.\r\n     * @param {parserlib.css.PropertyValue} value The property value to iterate over.\r\n     * @namespace parserlib.css\r\n     * @class PropertyValueIterator\r\n     * @constructor\r\n     */\r\n    function PropertyValueIterator(value){\r\n\r\n        /**\r\n         * Iterator value\r\n         * @type int\r\n         * @property _i\r\n         * @private\r\n         */\r\n        this._i = 0;\r\n\r\n        /**\r\n         * The parts that make up the value.\r\n         * @type Array\r\n         * @property _parts\r\n         * @private\r\n         */\r\n        this._parts = value.parts;\r\n\r\n        /**\r\n         * Keeps track of bookmarks along the way.\r\n         * @type Array\r\n         * @property _marks\r\n         * @private\r\n         */\r\n        this._marks = [];\r\n\r\n        /**\r\n         * Holds the original property value.\r\n         * @type parserlib.css.PropertyValue\r\n         * @property value\r\n         */\r\n        this.value = value;\r\n\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of parts in the value.\r\n     * @return {int} The total number of parts in the value.\r\n     * @method count\r\n     */\r\n    PropertyValueIterator.prototype.count = function(){\r\n        return this._parts.length;\r\n    };\r\n\r\n    /**\r\n     * Indicates if the iterator is positioned at the first item.\r\n     * @return {Boolean} True if positioned at first item, false if not.\r\n     * @method isFirst\r\n     */\r\n    PropertyValueIterator.prototype.isFirst = function(){\r\n        return this._i === 0;\r\n    };\r\n\r\n    /**\r\n     * Indicates if there are more parts of the property value.\r\n     * @return {Boolean} True if there are more parts, false if not.\r\n     * @method hasNext\r\n     */\r\n    PropertyValueIterator.prototype.hasNext = function(){\r\n        return (this._i < this._parts.length);\r\n    };\r\n\r\n    /**\r\n     * Marks the current spot in the iteration so it can be restored to\r\n     * later on.\r\n     * @return {void}\r\n     * @method mark\r\n     */\r\n    PropertyValueIterator.prototype.mark = function(){\r\n        this._marks.push(this._i);\r\n    };\r\n\r\n    /**\r\n     * Returns the next part of the property value or null if there is no next\r\n     * part. Does not move the internal counter forward.\r\n     * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next\r\n     * part.\r\n     * @method peek\r\n     */\r\n    PropertyValueIterator.prototype.peek = function(count){\r\n        return this.hasNext() ? this._parts[this._i + (count || 0)] : null;\r\n    };\r\n\r\n    /**\r\n     * Returns the next part of the property value or null if there is no next\r\n     * part.\r\n     * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next\r\n     * part.\r\n     * @method next\r\n     */\r\n    PropertyValueIterator.prototype.next = function(){\r\n        return this.hasNext() ? this._parts[this._i++] : null;\r\n    };\r\n\r\n    /**\r\n     * Returns the previous part of the property value or null if there is no\r\n     * previous part.\r\n     * @return {parserlib.css.PropertyValuePart} The previous part of the\r\n     * property value or null if there is no next part.\r\n     * @method previous\r\n     */\r\n    PropertyValueIterator.prototype.previous = function(){\r\n        return this._i > 0 ? this._parts[--this._i] : null;\r\n    };\r\n\r\n    /**\r\n     * Restores the last saved bookmark.\r\n     * @return {void}\r\n     * @method restore\r\n     */\r\n    PropertyValueIterator.prototype.restore = function(){\r\n        if (this._marks.length){\r\n            this._i = this._marks.pop();\r\n        }\r\n    };\r\n\r\n\r\n    /*global SyntaxUnit, Parser, Colors*/\r\n    /**\r\n     * Represents a single part of a CSS property value, meaning that it represents\r\n     * just one part of the data between \":\" and \";\".\r\n     * @param {String} text The text representation of the unit.\r\n     * @param {int} line The line of text on which the unit resides.\r\n     * @param {int} col The column of text on which the unit resides.\r\n     * @namespace parserlib.css\r\n     * @class PropertyValuePart\r\n     * @extends parserlib.util.SyntaxUnit\r\n     * @constructor\r\n     */\r\n    function PropertyValuePart(text, line, col){\r\n\r\n        SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);\r\n\r\n        /**\r\n         * Indicates the type of value unit.\r\n         * @type String\r\n         * @property type\r\n         */\r\n        this.type = \"unknown\";\r\n\r\n        //figure out what type of data it is\r\n\r\n        var temp;\r\n\r\n        //it is a measurement?\r\n        if (/^([+\\-]?[\\d\\.]+)([a-z]+)$/i.test(text)){  //dimension\r\n            this.type = \"dimension\";\r\n            this.value = +RegExp.$1;\r\n            this.units = RegExp.$2;\r\n\r\n            //try to narrow down\r\n            switch(this.units.toLowerCase()){\r\n\r\n                case \"em\":\r\n                case \"rem\":\r\n                case \"ex\":\r\n                case \"px\":\r\n                case \"cm\":\r\n                case \"mm\":\r\n                case \"in\":\r\n                case \"pt\":\r\n                case \"pc\":\r\n                case \"ch\":\r\n                case \"vh\":\r\n                case \"vw\":\r\n                case \"vm\":\r\n                    this.type = \"length\";\r\n                    break;\r\n\r\n                case \"deg\":\r\n                case \"rad\":\r\n                case \"grad\":\r\n                    this.type = \"angle\";\r\n                    break;\r\n\r\n                case \"ms\":\r\n                case \"s\":\r\n                    this.type = \"time\";\r\n                    break;\r\n\r\n                case \"hz\":\r\n                case \"khz\":\r\n                    this.type = \"frequency\";\r\n                    break;\r\n\r\n                case \"dpi\":\r\n                case \"dpcm\":\r\n                    this.type = \"resolution\";\r\n                    break;\r\n\r\n                //default\r\n\r\n            }\r\n\r\n        } else if (/^([+\\-]?[\\d\\.]+)%$/i.test(text)){  //percentage\r\n            this.type = \"percentage\";\r\n            this.value = +RegExp.$1;\r\n        } else if (/^([+\\-]?[\\d\\.]+)%$/i.test(text)){  //percentage\r\n            this.type = \"percentage\";\r\n            this.value = +RegExp.$1;\r\n        } else if (/^([+\\-]?\\d+)$/i.test(text)){  //integer\r\n            this.type = \"integer\";\r\n            this.value = +RegExp.$1;\r\n        } else if (/^([+\\-]?[\\d\\.]+)$/i.test(text)){  //number\r\n            this.type = \"number\";\r\n            this.value = +RegExp.$1;\r\n\r\n        } else if (/^#([a-f0-9]{3,6})/i.test(text)){  //hexcolor\r\n            this.type = \"color\";\r\n            temp = RegExp.$1;\r\n            if (temp.length == 3){\r\n                this.red    = parseInt(temp.charAt(0)+temp.charAt(0),16);\r\n                this.green  = parseInt(temp.charAt(1)+temp.charAt(1),16);\r\n                this.blue   = parseInt(temp.charAt(2)+temp.charAt(2),16);\r\n            } else {\r\n                this.red    = parseInt(temp.substring(0,2),16);\r\n                this.green  = parseInt(temp.substring(2,4),16);\r\n                this.blue   = parseInt(temp.substring(4,6),16);\r\n            }\r\n        } else if (/^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i.test(text)){ //rgb() color with absolute numbers\r\n            this.type   = \"color\";\r\n            this.red    = +RegExp.$1;\r\n            this.green  = +RegExp.$2;\r\n            this.blue   = +RegExp.$3;\r\n        } else if (/^rgb\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)){ //rgb() color with percentages\r\n            this.type   = \"color\";\r\n            this.red    = +RegExp.$1 * 255 / 100;\r\n            this.green  = +RegExp.$2 * 255 / 100;\r\n            this.blue   = +RegExp.$3 * 255 / 100;\r\n        } else if (/^rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)){ //rgba() color with absolute numbers\r\n            this.type   = \"color\";\r\n            this.red    = +RegExp.$1;\r\n            this.green  = +RegExp.$2;\r\n            this.blue   = +RegExp.$3;\r\n            this.alpha  = +RegExp.$4;\r\n        } else if (/^rgba\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)){ //rgba() color with percentages\r\n            this.type   = \"color\";\r\n            this.red    = +RegExp.$1 * 255 / 100;\r\n            this.green  = +RegExp.$2 * 255 / 100;\r\n            this.blue   = +RegExp.$3 * 255 / 100;\r\n            this.alpha  = +RegExp.$4;\r\n        } else if (/^hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)){ //hsl()\r\n            this.type   = \"color\";\r\n            this.hue    = +RegExp.$1;\r\n            this.saturation = +RegExp.$2 / 100;\r\n            this.lightness  = +RegExp.$3 / 100;\r\n        } else if (/^hsla\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)){ //hsla() color with percentages\r\n            this.type   = \"color\";\r\n            this.hue    = +RegExp.$1;\r\n            this.saturation = +RegExp.$2 / 100;\r\n            this.lightness  = +RegExp.$3 / 100;\r\n            this.alpha  = +RegExp.$4;\r\n        } else if (/^url\\([\"']?([^\\)\"']+)[\"']?\\)/i.test(text)){ //URI\r\n            this.type   = \"uri\";\r\n            this.uri    = RegExp.$1;\r\n        } else if (/^([^\\(]+)\\(/i.test(text)){\r\n            this.type   = \"function\";\r\n            this.name   = RegExp.$1;\r\n            this.value  = text;\r\n        } else if (/^[\"'][^\"']*[\"']/.test(text)){    //string\r\n            this.type   = \"string\";\r\n            this.value  = eval(text);\r\n        } else if (Colors[text.toLowerCase()]){  //named color\r\n            this.type   = \"color\";\r\n            temp        = Colors[text.toLowerCase()].substring(1);\r\n            this.red    = parseInt(temp.substring(0,2),16);\r\n            this.green  = parseInt(temp.substring(2,4),16);\r\n            this.blue   = parseInt(temp.substring(4,6),16);\r\n        } else if (/^[\\,\\/]$/.test(text)){\r\n            this.type   = \"operator\";\r\n            this.value  = text;\r\n        } else if (/^[a-z\\-\\u0080-\\uFFFF][a-z0-9\\-\\u0080-\\uFFFF]*$/i.test(text)){\r\n            this.type   = \"identifier\";\r\n            this.value  = text;\r\n        }\r\n\r\n    }\r\n\r\n    PropertyValuePart.prototype = new SyntaxUnit();\r\n    PropertyValuePart.prototype.constructor = PropertyValuePart;\r\n\r\n    /**\r\n     * Create a new syntax unit based solely on the given token.\r\n     * Convenience method for creating a new syntax unit when\r\n     * it represents a single token instead of multiple.\r\n     * @param {Object} token The token object to represent.\r\n     * @return {parserlib.css.PropertyValuePart} The object representing the token.\r\n     * @static\r\n     * @method fromToken\r\n     */\r\n    PropertyValuePart.fromToken = function(token){\r\n        return new PropertyValuePart(token.value, token.startLine, token.startCol);\r\n    };\r\n    var Pseudos = {\r\n        \":first-letter\": 1,\r\n        \":first-line\":   1,\r\n        \":before\":       1,\r\n        \":after\":        1\r\n    };\r\n\r\n    Pseudos.ELEMENT = 1;\r\n    Pseudos.CLASS = 2;\r\n\r\n    Pseudos.isElement = function(pseudo){\r\n        return pseudo.indexOf(\"::\") === 0 || Pseudos[pseudo.toLowerCase()] == Pseudos.ELEMENT;\r\n    };\r\n    /*global SyntaxUnit, Parser, Specificity*/\r\n    /**\r\n     * Represents an entire single selector, including all parts but not\r\n     * including multiple selectors (those separated by commas).\r\n     * @namespace parserlib.css\r\n     * @class Selector\r\n     * @extends parserlib.util.SyntaxUnit\r\n     * @constructor\r\n     * @param {Array} parts Array of selectors parts making up this selector.\r\n     * @param {int} line The line of text on which the unit resides.\r\n     * @param {int} col The column of text on which the unit resides.\r\n     */\r\n    function Selector(parts, line, col){\r\n\r\n        SyntaxUnit.call(this, parts.join(\" \"), line, col, Parser.SELECTOR_TYPE);\r\n\r\n        /**\r\n         * The parts that make up the selector.\r\n         * @type Array\r\n         * @property parts\r\n         */\r\n        this.parts = parts;\r\n\r\n        /**\r\n         * The specificity of the selector.\r\n         * @type parserlib.css.Specificity\r\n         * @property specificity\r\n         */\r\n        this.specificity = Specificity.calculate(this);\r\n\r\n    }\r\n\r\n    Selector.prototype = new SyntaxUnit();\r\n    Selector.prototype.constructor = Selector;\r\n\r\n\r\n    /*global SyntaxUnit, Parser*/\r\n    /**\r\n     * Represents a single part of a selector string, meaning a single set of\r\n     * element name and modifiers. This does not include combinators such as\r\n     * spaces, +, >, etc.\r\n     * @namespace parserlib.css\r\n     * @class SelectorPart\r\n     * @extends parserlib.util.SyntaxUnit\r\n     * @constructor\r\n     * @param {String} elementName The element name in the selector or null\r\n     *      if there is no element name.\r\n     * @param {Array} modifiers Array of individual modifiers for the element.\r\n     *      May be empty if there are none.\r\n     * @param {String} text The text representation of the unit.\r\n     * @param {int} line The line of text on which the unit resides.\r\n     * @param {int} col The column of text on which the unit resides.\r\n     */\r\n    function SelectorPart(elementName, modifiers, text, line, col){\r\n\r\n        SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);\r\n\r\n        /**\r\n         * The tag name of the element to which this part\r\n         * of the selector affects.\r\n         * @type String\r\n         * @property elementName\r\n         */\r\n        this.elementName = elementName;\r\n\r\n        /**\r\n         * The parts that come after the element name, such as class names, IDs,\r\n         * pseudo classes/elements, etc.\r\n         * @type Array\r\n         * @property modifiers\r\n         */\r\n        this.modifiers = modifiers;\r\n\r\n    }\r\n\r\n    SelectorPart.prototype = new SyntaxUnit();\r\n    SelectorPart.prototype.constructor = SelectorPart;\r\n\r\n\r\n    /*global SyntaxUnit, Parser*/\r\n    /**\r\n     * Represents a selector modifier string, meaning a class name, element name,\r\n     * element ID, pseudo rule, etc.\r\n     * @namespace parserlib.css\r\n     * @class SelectorSubPart\r\n     * @extends parserlib.util.SyntaxUnit\r\n     * @constructor\r\n     * @param {String} text The text representation of the unit.\r\n     * @param {String} type The type of selector modifier.\r\n     * @param {int} line The line of text on which the unit resides.\r\n     * @param {int} col The column of text on which the unit resides.\r\n     */\r\n    function SelectorSubPart(text, type, line, col){\r\n\r\n        SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);\r\n\r\n        /**\r\n         * The type of modifier.\r\n         * @type String\r\n         * @property type\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * Some subparts have arguments, this represents them.\r\n         * @type Array\r\n         * @property args\r\n         */\r\n        this.args = [];\r\n\r\n    }\r\n\r\n    SelectorSubPart.prototype = new SyntaxUnit();\r\n    SelectorSubPart.prototype.constructor = SelectorSubPart;\r\n\r\n\r\n    /*global Pseudos, SelectorPart*/\r\n    /**\r\n     * Represents a selector's specificity.\r\n     * @namespace parserlib.css\r\n     * @class Specificity\r\n     * @constructor\r\n     * @param {int} a Should be 1 for inline styles, zero for stylesheet styles\r\n     * @param {int} b Number of ID selectors\r\n     * @param {int} c Number of classes and pseudo classes\r\n     * @param {int} d Number of element names and pseudo elements\r\n     */\r\n    function Specificity(a, b, c, d){\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        this.d = d;\r\n    }\r\n\r\n    Specificity.prototype = {\r\n        constructor: Specificity,\r\n\r\n        /**\r\n         * Compare this specificity to another.\r\n         * @param {Specificity} other The other specificity to compare to.\r\n         * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.\r\n         * @method compare\r\n         */\r\n        compare: function(other){\r\n            var comps = [\"a\", \"b\", \"c\", \"d\"],\r\n                i, len;\r\n\r\n            for (i=0, len=comps.length; i < len; i++){\r\n                if (this[comps[i]] < other[comps[i]]){\r\n                    return -1;\r\n                } else if (this[comps[i]] > other[comps[i]]){\r\n                    return 1;\r\n                }\r\n            }\r\n\r\n            return 0;\r\n        },\r\n\r\n        /**\r\n         * Creates a numeric value for the specificity.\r\n         * @return {int} The numeric value for the specificity.\r\n         * @method valueOf\r\n         */\r\n        valueOf: function(){\r\n            return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;\r\n        },\r\n\r\n        /**\r\n         * Returns a string representation for specificity.\r\n         * @return {String} The string representation of specificity.\r\n         * @method toString\r\n         */\r\n        toString: function(){\r\n            return this.a + \",\" + this.b + \",\" + this.c + \",\" + this.d;\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Calculates the specificity of the given selector.\r\n     * @param {parserlib.css.Selector} The selector to calculate specificity for.\r\n     * @return {parserlib.css.Specificity} The specificity of the selector.\r\n     * @static\r\n     * @method calculate\r\n     */\r\n    Specificity.calculate = function(selector){\r\n\r\n        var i, len,\r\n            part,\r\n            b=0, c=0, d=0;\r\n\r\n        function updateValues(part){\r\n\r\n            var i, j, len, num,\r\n                elementName = part.elementName ? part.elementName.text : \"\",\r\n                modifier;\r\n\r\n            if (elementName && elementName.charAt(elementName.length-1) != \"*\") {\r\n                d++;\r\n            }\r\n\r\n            for (i=0, len=part.modifiers.length; i < len; i++){\r\n                modifier = part.modifiers[i];\r\n                switch(modifier.type){\r\n                    case \"class\":\r\n                    case \"attribute\":\r\n                        c++;\r\n                        break;\r\n\r\n                    case \"id\":\r\n                        b++;\r\n                        break;\r\n\r\n                    case \"pseudo\":\r\n                        if (Pseudos.isElement(modifier.text)){\r\n                            d++;\r\n                        } else {\r\n                            c++;\r\n                        }\r\n                        break;\r\n\r\n                    case \"not\":\r\n                        for (j=0, num=modifier.args.length; j < num; j++){\r\n                            updateValues(modifier.args[j]);\r\n                        }\r\n                }\r\n             }\r\n        }\r\n\r\n        for (i=0, len=selector.parts.length; i < len; i++){\r\n            part = selector.parts[i];\r\n\r\n            if (part instanceof SelectorPart){\r\n                updateValues(part);\r\n            }\r\n        }\r\n\r\n        return new Specificity(0, b, c, d);\r\n    };\r\n\r\n    /*global Tokens, TokenStreamBase*/\r\n\r\n    var h = /^[0-9a-fA-F]$/,\r\n        nonascii = /^[\\u0080-\\uFFFF]$/,\r\n        nl = /\\n|\\r\\n|\\r|\\f/;\r\n\r\n    //-----------------------------------------------------------------------------\r\n    // Helper functions\r\n    //-----------------------------------------------------------------------------\r\n\r\n\r\n    function isHexDigit(c){\r\n        return c !== null && h.test(c);\r\n    }\r\n\r\n    function isDigit(c){\r\n        return c !== null && /\\d/.test(c);\r\n    }\r\n\r\n    function isWhitespace(c){\r\n        return c !== null && /\\s/.test(c);\r\n    }\r\n\r\n    function isNewLine(c){\r\n        return c !== null && nl.test(c);\r\n    }\r\n\r\n    function isNameStart(c){\r\n        return c !== null && (/[a-z_\\u0080-\\uFFFF\\\\]/i.test(c));\r\n    }\r\n\r\n    function isNameChar(c){\r\n        return c !== null && (isNameStart(c) || /[0-9\\-\\\\]/.test(c));\r\n    }\r\n\r\n    function isIdentStart(c){\r\n        return c !== null && (isNameStart(c) || /\\-\\\\/.test(c));\r\n    }\r\n\r\n    function mix(receiver, supplier){\r\n        for (var prop in supplier){\r\n            if (supplier.hasOwnProperty(prop)){\r\n                receiver[prop] = supplier[prop];\r\n            }\r\n        }\r\n        return receiver;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------\r\n    // CSS Token Stream\r\n    //-----------------------------------------------------------------------------\r\n\r\n\r\n    /**\r\n     * A token stream that produces CSS tokens.\r\n     * @param {String|Reader} input The source of text to tokenize.\r\n     * @constructor\r\n     * @class TokenStream\r\n     * @namespace parserlib.css\r\n     */\r\n    function TokenStream(input){\r\n        TokenStreamBase.call(this, input, Tokens);\r\n    }\r\n\r\n    TokenStream.prototype = mix(new TokenStreamBase(), {\r\n\r\n        /**\r\n         * Overrides the TokenStreamBase method of the same name\r\n         * to produce CSS tokens.\r\n         * @param {variant} channel The name of the channel to use\r\n         *      for the next token.\r\n         * @return {Object} A token object representing the next token.\r\n         * @method _getToken\r\n         * @private\r\n         */\r\n        _getToken: function(channel){\r\n\r\n            var c,\r\n                reader = this._reader,\r\n                token   = null,\r\n                startLine   = reader.getLine(),\r\n                startCol    = reader.getCol();\r\n\r\n            c = reader.read();\r\n\r\n\r\n            while(c){\r\n                switch(c){\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - COMMENT\r\n                     * - SLASH\r\n                     * - CHAR\r\n                     */\r\n                    case \"/\":\r\n\r\n                        if(reader.peek() == \"*\"){\r\n                            token = this.commentToken(c, startLine, startCol);\r\n                        } else {\r\n                            token = this.charToken(c, startLine, startCol);\r\n                        }\r\n                        break;\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - DASHMATCH\r\n                     * - INCLUDES\r\n                     * - PREFIXMATCH\r\n                     * - SUFFIXMATCH\r\n                     * - SUBSTRINGMATCH\r\n                     * - CHAR\r\n                     */\r\n                    case \"|\":\r\n                    case \"~\":\r\n                    case \"^\":\r\n                    case \"$\":\r\n                    case \"*\":\r\n                        if(reader.peek() == \"=\"){\r\n                            token = this.comparisonToken(c, startLine, startCol);\r\n                        } else {\r\n                            token = this.charToken(c, startLine, startCol);\r\n                        }\r\n                        break;\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - STRING\r\n                     * - INVALID\r\n                     */\r\n                    case \"\\\"\":\r\n                    case \"'\":\r\n                        token = this.stringToken(c, startLine, startCol);\r\n                        break;\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - HASH\r\n                     * - CHAR\r\n                     */\r\n                    case \"#\":\r\n                        if (isNameChar(reader.peek())){\r\n                            token = this.hashToken(c, startLine, startCol);\r\n                        } else {\r\n                            token = this.charToken(c, startLine, startCol);\r\n                        }\r\n                        break;\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - DOT\r\n                     * - NUMBER\r\n                     * - DIMENSION\r\n                     * - PERCENTAGE\r\n                     */\r\n                    case \".\":\r\n                        if (isDigit(reader.peek())){\r\n                            token = this.numberToken(c, startLine, startCol);\r\n                        } else {\r\n                            token = this.charToken(c, startLine, startCol);\r\n                        }\r\n                        break;\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - CDC\r\n                     * - MINUS\r\n                     * - NUMBER\r\n                     * - DIMENSION\r\n                     * - PERCENTAGE\r\n                     */\r\n                    case \"-\":\r\n                        if (reader.peek() == \"-\"){  //could be closing HTML-style comment\r\n                            token = this.htmlCommentEndToken(c, startLine, startCol);\r\n                        } else if (isNameStart(reader.peek())){\r\n                            token = this.identOrFunctionToken(c, startLine, startCol);\r\n                        } else {\r\n                            token = this.charToken(c, startLine, startCol);\r\n                        }\r\n                        break;\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - IMPORTANT_SYM\r\n                     * - CHAR\r\n                     */\r\n                    case \"!\":\r\n                        token = this.importantToken(c, startLine, startCol);\r\n                        break;\r\n\r\n                    /*\r\n                     * Any at-keyword or CHAR\r\n                     */\r\n                    case \"@\":\r\n                        token = this.atRuleToken(c, startLine, startCol);\r\n                        break;\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - NOT\r\n                     * - CHAR\r\n                     */\r\n                    case \":\":\r\n                        token = this.notToken(c, startLine, startCol);\r\n                        break;\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - CDO\r\n                     * - CHAR\r\n                     */\r\n                    case \"<\":\r\n                        token = this.htmlCommentStartToken(c, startLine, startCol);\r\n                        break;\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - UNICODE_RANGE\r\n                     * - URL\r\n                     * - CHAR\r\n                     */\r\n                    case \"U\":\r\n                    case \"u\":\r\n                        if (reader.peek() == \"+\"){\r\n                            token = this.unicodeRangeToken(c, startLine, startCol);\r\n                            break;\r\n                        }\r\n                        /* falls through */\r\n                    default:\r\n\r\n                        /*\r\n                         * Potential tokens:\r\n                         * - NUMBER\r\n                         * - DIMENSION\r\n                         * - LENGTH\r\n                         * - FREQ\r\n                         * - TIME\r\n                         * - EMS\r\n                         * - EXS\r\n                         * - ANGLE\r\n                         */\r\n                        if (isDigit(c)){\r\n                            token = this.numberToken(c, startLine, startCol);\r\n                        } else\r\n\r\n                        /*\r\n                         * Potential tokens:\r\n                         * - S\r\n                         */\r\n                        if (isWhitespace(c)){\r\n                            token = this.whitespaceToken(c, startLine, startCol);\r\n                        } else\r\n\r\n                        /*\r\n                         * Potential tokens:\r\n                         * - IDENT\r\n                         */\r\n                        if (isIdentStart(c)){\r\n                            token = this.identOrFunctionToken(c, startLine, startCol);\r\n                        } else\r\n\r\n                        /*\r\n                         * Potential tokens:\r\n                         * - CHAR\r\n                         * - PLUS\r\n                         */\r\n                        {\r\n                            token = this.charToken(c, startLine, startCol);\r\n                        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n                }\r\n\r\n                //make sure this token is wanted\r\n                //TODO: check channel\r\n                break;\r\n            }\r\n\r\n            if (!token && c === null){\r\n                token = this.createToken(Tokens.EOF,null,startLine,startCol);\r\n            }\r\n\r\n            return token;\r\n        },\r\n\r\n        //-------------------------------------------------------------------------\r\n        // Methods to create tokens\r\n        //-------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Produces a token based on available data and the current\r\n         * reader position information. This method is called by other\r\n         * private methods to create tokens and is never called directly.\r\n         * @param {int} tt The token type.\r\n         * @param {String} value The text value of the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @param {Object} options (Optional) Specifies a channel property\r\n         *      to indicate that a different channel should be scanned\r\n         *      and/or a hide property indicating that the token should\r\n         *      be hidden.\r\n         * @return {Object} A token object.\r\n         * @method createToken\r\n         */\r\n        createToken: function(tt, value, startLine, startCol, options){\r\n            var reader = this._reader;\r\n            options = options || {};\r\n\r\n            return {\r\n                value:      value,\r\n                type:       tt,\r\n                channel:    options.channel,\r\n                hide:       options.hide || false,\r\n                startLine:  startLine,\r\n                startCol:   startCol,\r\n                endLine:    reader.getLine(),\r\n                endCol:     reader.getCol()\r\n            };\r\n        },\r\n\r\n        //-------------------------------------------------------------------------\r\n        // Methods to create specific tokens\r\n        //-------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Produces a token for any at-rule. If the at-rule is unknown, then\r\n         * the token is for a single \"@\" character.\r\n         * @param {String} first The first character for the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method atRuleToken\r\n         */\r\n        atRuleToken: function(first, startLine, startCol){\r\n            var rule    = first,\r\n                reader  = this._reader,\r\n                tt      = Tokens.CHAR,\r\n                valid   = false,\r\n                ident,\r\n                c;\r\n\r\n            /*\r\n             * First, mark where we are. There are only four @ rules,\r\n             * so anything else is really just an invalid token.\r\n             * Basically, if this doesn't match one of the known @\r\n             * rules, just return '@' as an unknown token and allow\r\n             * parsing to continue after that point.\r\n             */\r\n            reader.mark();\r\n\r\n            //try to find the at-keyword\r\n            ident = this.readName();\r\n            rule = first + ident;\r\n            tt = Tokens.type(rule.toLowerCase());\r\n\r\n            //if it's not valid, use the first character only and reset the reader\r\n            if (tt == Tokens.CHAR || tt == Tokens.UNKNOWN){\r\n                if (rule.length > 1){\r\n                    tt = Tokens.UNKNOWN_SYM;\r\n                } else {\r\n                    tt = Tokens.CHAR;\r\n                    rule = first;\r\n                    reader.reset();\r\n                }\r\n            }\r\n\r\n            return this.createToken(tt, rule, startLine, startCol);\r\n        },\r\n\r\n        /**\r\n         * Produces a character token based on the given character\r\n         * and location in the stream. If there's a special (non-standard)\r\n         * token name, this is used; otherwise CHAR is used.\r\n         * @param {String} c The character for the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method charToken\r\n         */\r\n        charToken: function(c, startLine, startCol){\r\n            var tt = Tokens.type(c);\r\n\r\n            if (tt == -1){\r\n                tt = Tokens.CHAR;\r\n            }\r\n\r\n            return this.createToken(tt, c, startLine, startCol);\r\n        },\r\n\r\n        /**\r\n         * Produces a character token based on the given character\r\n         * and location in the stream. If there's a special (non-standard)\r\n         * token name, this is used; otherwise CHAR is used.\r\n         * @param {String} first The first character for the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method commentToken\r\n         */\r\n        commentToken: function(first, startLine, startCol){\r\n            var reader  = this._reader,\r\n                comment = this.readComment(first);\r\n\r\n            return this.createToken(Tokens.COMMENT, comment, startLine, startCol);\r\n        },\r\n\r\n        /**\r\n         * Produces a comparison token based on the given character\r\n         * and location in the stream. The next character must be\r\n         * read and is already known to be an equals sign.\r\n         * @param {String} c The character for the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method comparisonToken\r\n         */\r\n        comparisonToken: function(c, startLine, startCol){\r\n            var reader  = this._reader,\r\n                comparison  = c + reader.read(),\r\n                tt      = Tokens.type(comparison) || Tokens.CHAR;\r\n\r\n            return this.createToken(tt, comparison, startLine, startCol);\r\n        },\r\n\r\n        /**\r\n         * Produces a hash token based on the specified information. The\r\n         * first character provided is the pound sign (#) and then this\r\n         * method reads a name afterward.\r\n         * @param {String} first The first character (#) in the hash name.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method hashToken\r\n         */\r\n        hashToken: function(first, startLine, startCol){\r\n            var reader  = this._reader,\r\n                name    = this.readName(first);\r\n\r\n            return this.createToken(Tokens.HASH, name, startLine, startCol);\r\n        },\r\n\r\n        /**\r\n         * Produces a CDO or CHAR token based on the specified information. The\r\n         * first character is provided and the rest is read by the function to determine\r\n         * the correct token to create.\r\n         * @param {String} first The first character in the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method htmlCommentStartToken\r\n         */\r\n        htmlCommentStartToken: function(first, startLine, startCol){\r\n            var reader      = this._reader,\r\n                text        = first;\r\n\r\n            reader.mark();\r\n            text += reader.readCount(3);\r\n\r\n            if (text == \"<!--\"){\r\n                return this.createToken(Tokens.CDO, text, startLine, startCol);\r\n            } else {\r\n                reader.reset();\r\n                return this.charToken(first, startLine, startCol);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Produces a CDC or CHAR token based on the specified information. The\r\n         * first character is provided and the rest is read by the function to determine\r\n         * the correct token to create.\r\n         * @param {String} first The first character in the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method htmlCommentEndToken\r\n         */\r\n        htmlCommentEndToken: function(first, startLine, startCol){\r\n            var reader      = this._reader,\r\n                text        = first;\r\n\r\n            reader.mark();\r\n            text += reader.readCount(2);\r\n\r\n            if (text == \"-->\"){\r\n                return this.createToken(Tokens.CDC, text, startLine, startCol);\r\n            } else {\r\n                reader.reset();\r\n                return this.charToken(first, startLine, startCol);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Produces an IDENT or FUNCTION token based on the specified information. The\r\n         * first character is provided and the rest is read by the function to determine\r\n         * the correct token to create.\r\n         * @param {String} first The first character in the identifier.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method identOrFunctionToken\r\n         */\r\n        identOrFunctionToken: function(first, startLine, startCol){\r\n            var reader  = this._reader,\r\n                ident   = this.readName(first),\r\n                tt      = Tokens.IDENT;\r\n\r\n            //if there's a left paren immediately after, it's a URI or function\r\n            if (reader.peek() == \"(\"){\r\n                ident += reader.read();\r\n                if (ident.toLowerCase() == \"url(\"){\r\n                    tt = Tokens.URI;\r\n                    ident = this.readURI(ident);\r\n\r\n                    //didn't find a valid URL or there's no closing paren\r\n                    if (ident.toLowerCase() == \"url(\"){\r\n                        tt = Tokens.FUNCTION;\r\n                    }\r\n                } else {\r\n                    tt = Tokens.FUNCTION;\r\n                }\r\n            } else if (reader.peek() == \":\"){  //might be an IE function\r\n\r\n                //IE-specific functions always being with progid:\r\n                if (ident.toLowerCase() == \"progid\"){\r\n                    ident += reader.readTo(\"(\");\r\n                    tt = Tokens.IE_FUNCTION;\r\n                }\r\n            }\r\n\r\n            return this.createToken(tt, ident, startLine, startCol);\r\n        },\r\n\r\n        /**\r\n         * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The\r\n         * first character is provided and the rest is read by the function to determine\r\n         * the correct token to create.\r\n         * @param {String} first The first character in the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method importantToken\r\n         */\r\n        importantToken: function(first, startLine, startCol){\r\n            var reader      = this._reader,\r\n                important   = first,\r\n                tt          = Tokens.CHAR,\r\n                temp,\r\n                c;\r\n\r\n            reader.mark();\r\n            c = reader.read();\r\n\r\n            while(c){\r\n\r\n                //there can be a comment in here\r\n                if (c == \"/\"){\r\n\r\n                    //if the next character isn't a star, then this isn't a valid !important token\r\n                    if (reader.peek() != \"*\"){\r\n                        break;\r\n                    } else {\r\n                        temp = this.readComment(c);\r\n                        if (temp === \"\"){    //broken!\r\n                            break;\r\n                        }\r\n                    }\r\n                } else if (isWhitespace(c)){\r\n                    important += c + this.readWhitespace();\r\n                } else if (/i/i.test(c)){\r\n                    temp = reader.readCount(8);\r\n                    if (/mportant/i.test(temp)){\r\n                        important += c + temp;\r\n                        tt = Tokens.IMPORTANT_SYM;\r\n\r\n                    }\r\n                    break;  //we're done\r\n                } else {\r\n                    break;\r\n                }\r\n\r\n                c = reader.read();\r\n            }\r\n\r\n            if (tt == Tokens.CHAR){\r\n                reader.reset();\r\n                return this.charToken(first, startLine, startCol);\r\n            } else {\r\n                return this.createToken(tt, important, startLine, startCol);\r\n            }\r\n\r\n\r\n        },\r\n\r\n        /**\r\n         * Produces a NOT or CHAR token based on the specified information. The\r\n         * first character is provided and the rest is read by the function to determine\r\n         * the correct token to create.\r\n         * @param {String} first The first character in the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method notToken\r\n         */\r\n        notToken: function(first, startLine, startCol){\r\n            var reader      = this._reader,\r\n                text        = first;\r\n\r\n            reader.mark();\r\n            text += reader.readCount(4);\r\n\r\n            if (text.toLowerCase() == \":not(\"){\r\n                return this.createToken(Tokens.NOT, text, startLine, startCol);\r\n            } else {\r\n                reader.reset();\r\n                return this.charToken(first, startLine, startCol);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Produces a number token based on the given character\r\n         * and location in the stream. This may return a token of\r\n         * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,\r\n         * or PERCENTAGE.\r\n         * @param {String} first The first character for the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method numberToken\r\n         */\r\n        numberToken: function(first, startLine, startCol){\r\n            var reader  = this._reader,\r\n                value   = this.readNumber(first),\r\n                ident,\r\n                tt      = Tokens.NUMBER,\r\n                c       = reader.peek();\r\n\r\n            if (isIdentStart(c)){\r\n                ident = this.readName(reader.read());\r\n                value += ident;\r\n\r\n                if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vm$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)){\r\n                    tt = Tokens.LENGTH;\r\n                } else if (/^deg|^rad$|^grad$/i.test(ident)){\r\n                    tt = Tokens.ANGLE;\r\n                } else if (/^ms$|^s$/i.test(ident)){\r\n                    tt = Tokens.TIME;\r\n                } else if (/^hz$|^khz$/i.test(ident)){\r\n                    tt = Tokens.FREQ;\r\n                } else if (/^dpi$|^dpcm$/i.test(ident)){\r\n                    tt = Tokens.RESOLUTION;\r\n                } else {\r\n                    tt = Tokens.DIMENSION;\r\n                }\r\n\r\n            } else if (c == \"%\"){\r\n                value += reader.read();\r\n                tt = Tokens.PERCENTAGE;\r\n            }\r\n\r\n            return this.createToken(tt, value, startLine, startCol);\r\n        },\r\n\r\n        /**\r\n         * Produces a string token based on the given character\r\n         * and location in the stream. Since strings may be indicated\r\n         * by single or double quotes, a failure to match starting\r\n         * and ending quotes results in an INVALID token being generated.\r\n         * The first character in the string is passed in and then\r\n         * the rest are read up to and including the final quotation mark.\r\n         * @param {String} first The first character in the string.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method stringToken\r\n         */\r\n        stringToken: function(first, startLine, startCol){\r\n            var delim   = first,\r\n                string  = first,\r\n                reader  = this._reader,\r\n                prev    = first,\r\n                tt      = Tokens.STRING,\r\n                c       = reader.read();\r\n\r\n            while(c){\r\n                string += c;\r\n\r\n                //if the delimiter is found with an escapement, we're done.\r\n                if (c == delim && prev != \"\\\\\"){\r\n                    break;\r\n                }\r\n\r\n                //if there's a newline without an escapement, it's an invalid string\r\n                if (isNewLine(reader.peek()) && c != \"\\\\\"){\r\n                    tt = Tokens.INVALID;\r\n                    break;\r\n                }\r\n\r\n                //save previous and get next\r\n                prev = c;\r\n                c = reader.read();\r\n            }\r\n\r\n            //if c is null, that means we're out of input and the string was never closed\r\n            if (c === null){\r\n                tt = Tokens.INVALID;\r\n            }\r\n\r\n            return this.createToken(tt, string, startLine, startCol);\r\n        },\r\n\r\n        unicodeRangeToken: function(first, startLine, startCol){\r\n            var reader  = this._reader,\r\n                value   = first,\r\n                temp,\r\n                tt      = Tokens.CHAR;\r\n\r\n            //then it should be a unicode range\r\n            if (reader.peek() == \"+\"){\r\n                reader.mark();\r\n                value += reader.read();\r\n                value += this.readUnicodeRangePart(true);\r\n\r\n                //ensure there's an actual unicode range here\r\n                if (value.length == 2){\r\n                    reader.reset();\r\n                } else {\r\n\r\n                    tt = Tokens.UNICODE_RANGE;\r\n\r\n                    //if there's a ? in the first part, there can't be a second part\r\n                    if (value.indexOf(\"?\") == -1){\r\n\r\n                        if (reader.peek() == \"-\"){\r\n                            reader.mark();\r\n                            temp = reader.read();\r\n                            temp += this.readUnicodeRangePart(false);\r\n\r\n                            //if there's not another value, back up and just take the first\r\n                            if (temp.length == 1){\r\n                                reader.reset();\r\n                            } else {\r\n                                value += temp;\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this.createToken(tt, value, startLine, startCol);\r\n        },\r\n\r\n        /**\r\n         * Produces a S token based on the specified information. Since whitespace\r\n         * may have multiple characters, this consumes all whitespace characters\r\n         * into a single token.\r\n         * @param {String} first The first character in the token.\r\n         * @param {int} startLine The beginning line for the character.\r\n         * @param {int} startCol The beginning column for the character.\r\n         * @return {Object} A token object.\r\n         * @method whitespaceToken\r\n         */\r\n        whitespaceToken: function(first, startLine, startCol){\r\n            var reader  = this._reader,\r\n                value   = first + this.readWhitespace();\r\n            return this.createToken(Tokens.S, value, startLine, startCol);\r\n        },\r\n\r\n\r\n\r\n\r\n        //-------------------------------------------------------------------------\r\n        // Methods to read values from the string stream\r\n        //-------------------------------------------------------------------------\r\n\r\n        readUnicodeRangePart: function(allowQuestionMark){\r\n            var reader  = this._reader,\r\n                part = \"\",\r\n                c       = reader.peek();\r\n\r\n            //first read hex digits\r\n            while(isHexDigit(c) && part.length < 6){\r\n                reader.read();\r\n                part += c;\r\n                c = reader.peek();\r\n            }\r\n\r\n            //then read question marks if allowed\r\n            if (allowQuestionMark){\r\n                while(c == \"?\" && part.length < 6){\r\n                    reader.read();\r\n                    part += c;\r\n                    c = reader.peek();\r\n                }\r\n            }\r\n\r\n            //there can't be any other characters after this point\r\n\r\n            return part;\r\n        },\r\n\r\n        readWhitespace: function(){\r\n            var reader  = this._reader,\r\n                whitespace = \"\",\r\n                c       = reader.peek();\r\n\r\n            while(isWhitespace(c)){\r\n                reader.read();\r\n                whitespace += c;\r\n                c = reader.peek();\r\n            }\r\n\r\n            return whitespace;\r\n        },\r\n        readNumber: function(first){\r\n            var reader  = this._reader,\r\n                number  = first,\r\n                hasDot  = (first == \".\"),\r\n                c       = reader.peek();\r\n\r\n\r\n            while(c){\r\n                if (isDigit(c)){\r\n                    number += reader.read();\r\n                } else if (c == \".\"){\r\n                    if (hasDot){\r\n                        break;\r\n                    } else {\r\n                        hasDot = true;\r\n                        number += reader.read();\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n\r\n                c = reader.peek();\r\n            }\r\n\r\n            return number;\r\n        },\r\n        readString: function(){\r\n            var reader  = this._reader,\r\n                delim   = reader.read(),\r\n                string  = delim,\r\n                prev    = delim,\r\n                c       = reader.peek();\r\n\r\n            while(c){\r\n                c = reader.read();\r\n                string += c;\r\n\r\n                //if the delimiter is found with an escapement, we're done.\r\n                if (c == delim && prev != \"\\\\\"){\r\n                    break;\r\n                }\r\n\r\n                //if there's a newline without an escapement, it's an invalid string\r\n                if (isNewLine(reader.peek()) && c != \"\\\\\"){\r\n                    string = \"\";\r\n                    break;\r\n                }\r\n\r\n                //save previous and get next\r\n                prev = c;\r\n                c = reader.peek();\r\n            }\r\n\r\n            //if c is null, that means we're out of input and the string was never closed\r\n            if (c === null){\r\n                string = \"\";\r\n            }\r\n\r\n            return string;\r\n        },\r\n        readURI: function(first){\r\n            var reader  = this._reader,\r\n                uri     = first,\r\n                inner   = \"\",\r\n                c       = reader.peek();\r\n\r\n            reader.mark();\r\n\r\n            //skip whitespace before\r\n            while(c && isWhitespace(c)){\r\n                reader.read();\r\n                c = reader.peek();\r\n            }\r\n\r\n            //it's a string\r\n            if (c == \"'\" || c == \"\\\"\"){\r\n                inner = this.readString();\r\n            } else {\r\n                inner = this.readURL();\r\n            }\r\n\r\n            c = reader.peek();\r\n\r\n            //skip whitespace after\r\n            while(c && isWhitespace(c)){\r\n                reader.read();\r\n                c = reader.peek();\r\n            }\r\n\r\n            //if there was no inner value or the next character isn't closing paren, it's not a URI\r\n            if (inner === \"\" || c != \")\"){\r\n                uri = first;\r\n                reader.reset();\r\n            } else {\r\n                uri += inner + reader.read();\r\n            }\r\n\r\n            return uri;\r\n        },\r\n        readURL: function(){\r\n            var reader  = this._reader,\r\n                url     = \"\",\r\n                c       = reader.peek();\r\n\r\n            //TODO: Check for escape and nonascii\r\n            while (/^[!#$%&\\\\*-~]$/.test(c)){\r\n                url += reader.read();\r\n                c = reader.peek();\r\n            }\r\n\r\n            return url;\r\n\r\n        },\r\n        readName: function(first){\r\n            var reader  = this._reader,\r\n                ident   = first || \"\",\r\n                c       = reader.peek();\r\n\r\n            while(true){\r\n                if (c == \"\\\\\"){\r\n                    ident += this.readEscape(reader.read());\r\n                    c = reader.peek();\r\n                } else if(c && isNameChar(c)){\r\n                    ident += reader.read();\r\n                    c = reader.peek();\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return ident;\r\n        },\r\n\r\n        readEscape: function(first){\r\n            var reader  = this._reader,\r\n                cssEscape = first || \"\",\r\n                i       = 0,\r\n                c       = reader.peek();\r\n\r\n            if (isHexDigit(c)){\r\n                do {\r\n                    cssEscape += reader.read();\r\n                    c = reader.peek();\r\n                } while(c && isHexDigit(c) && ++i < 6);\r\n            }\r\n\r\n            if (cssEscape.length == 3 && /\\s/.test(c) ||\r\n                cssEscape.length == 7 || cssEscape.length == 1){\r\n                    reader.read();\r\n            } else {\r\n                c = \"\";\r\n            }\r\n\r\n            return cssEscape + c;\r\n        },\r\n\r\n        readComment: function(first){\r\n            var reader  = this._reader,\r\n                comment = first || \"\",\r\n                c       = reader.read();\r\n\r\n            if (c == \"*\"){\r\n                while(c){\r\n                    comment += c;\r\n\r\n                    //look for end of comment\r\n                    if (comment.length > 2 && c == \"*\" && reader.peek() == \"/\"){\r\n                        comment += reader.read();\r\n                        break;\r\n                    }\r\n\r\n                    c = reader.read();\r\n                }\r\n\r\n                return comment;\r\n            } else {\r\n                return \"\";\r\n            }\r\n\r\n        }\r\n    });\r\n\r\n\r\n    var Tokens  = [\r\n\r\n        /*\r\n         * The following token names are defined in CSS3 Grammar: http://www.w3.org/TR/css3-syntax/#lexical\r\n         */\r\n\r\n        //HTML-style comments\r\n        { name: \"CDO\"},\r\n        { name: \"CDC\"},\r\n\r\n        //ignorables\r\n        { name: \"S\", whitespace: true/*, channel: \"ws\"*/},\r\n        { name: \"COMMENT\", comment: true, hide: true, channel: \"comment\" },\r\n\r\n        //attribute equality\r\n        { name: \"INCLUDES\", text: \"~=\"},\r\n        { name: \"DASHMATCH\", text: \"|=\"},\r\n        { name: \"PREFIXMATCH\", text: \"^=\"},\r\n        { name: \"SUFFIXMATCH\", text: \"$=\"},\r\n        { name: \"SUBSTRINGMATCH\", text: \"*=\"},\r\n\r\n        //identifier types\r\n        { name: \"STRING\"},\r\n        { name: \"IDENT\"},\r\n        { name: \"HASH\"},\r\n\r\n        //at-keywords\r\n        { name: \"IMPORT_SYM\", text: \"@import\"},\r\n        { name: \"PAGE_SYM\", text: \"@page\"},\r\n        { name: \"MEDIA_SYM\", text: \"@media\"},\r\n        { name: \"FONT_FACE_SYM\", text: \"@font-face\"},\r\n        { name: \"CHARSET_SYM\", text: \"@charset\"},\r\n        { name: \"NAMESPACE_SYM\", text: \"@namespace\"},\r\n        { name: \"VIEWPORT_SYM\", text: \"@viewport\"},\r\n        { name: \"UNKNOWN_SYM\" },\r\n        //{ name: \"ATKEYWORD\"},\r\n\r\n        //CSS3 animations\r\n        { name: \"KEYFRAMES_SYM\", text: [ \"@keyframes\", \"@-webkit-keyframes\", \"@-moz-keyframes\", \"@-o-keyframes\" ] },\r\n\r\n        //important symbol\r\n        { name: \"IMPORTANT_SYM\"},\r\n\r\n        //measurements\r\n        { name: \"LENGTH\"},\r\n        { name: \"ANGLE\"},\r\n        { name: \"TIME\"},\r\n        { name: \"FREQ\"},\r\n        { name: \"DIMENSION\"},\r\n        { name: \"PERCENTAGE\"},\r\n        { name: \"NUMBER\"},\r\n\r\n        //functions\r\n        { name: \"URI\"},\r\n        { name: \"FUNCTION\"},\r\n\r\n        //Unicode ranges\r\n        { name: \"UNICODE_RANGE\"},\r\n\r\n        /*\r\n         * The following token names are defined in CSS3 Selectors: http://www.w3.org/TR/css3-selectors/#selector-syntax\r\n         */\r\n\r\n        //invalid string\r\n        { name: \"INVALID\"},\r\n\r\n        //combinators\r\n        { name: \"PLUS\", text: \"+\" },\r\n        { name: \"GREATER\", text: \">\"},\r\n        { name: \"COMMA\", text: \",\"},\r\n        { name: \"TILDE\", text: \"~\"},\r\n\r\n        //modifier\r\n        { name: \"NOT\"},\r\n\r\n        /*\r\n         * Defined in CSS3 Paged Media\r\n         */\r\n        { name: \"TOPLEFTCORNER_SYM\", text: \"@top-left-corner\"},\r\n        { name: \"TOPLEFT_SYM\", text: \"@top-left\"},\r\n        { name: \"TOPCENTER_SYM\", text: \"@top-center\"},\r\n        { name: \"TOPRIGHT_SYM\", text: \"@top-right\"},\r\n        { name: \"TOPRIGHTCORNER_SYM\", text: \"@top-right-corner\"},\r\n        { name: \"BOTTOMLEFTCORNER_SYM\", text: \"@bottom-left-corner\"},\r\n        { name: \"BOTTOMLEFT_SYM\", text: \"@bottom-left\"},\r\n        { name: \"BOTTOMCENTER_SYM\", text: \"@bottom-center\"},\r\n        { name: \"BOTTOMRIGHT_SYM\", text: \"@bottom-right\"},\r\n        { name: \"BOTTOMRIGHTCORNER_SYM\", text: \"@bottom-right-corner\"},\r\n        { name: \"LEFTTOP_SYM\", text: \"@left-top\"},\r\n        { name: \"LEFTMIDDLE_SYM\", text: \"@left-middle\"},\r\n        { name: \"LEFTBOTTOM_SYM\", text: \"@left-bottom\"},\r\n        { name: \"RIGHTTOP_SYM\", text: \"@right-top\"},\r\n        { name: \"RIGHTMIDDLE_SYM\", text: \"@right-middle\"},\r\n        { name: \"RIGHTBOTTOM_SYM\", text: \"@right-bottom\"},\r\n\r\n        /*\r\n         * The following token names are defined in CSS3 Media Queries: http://www.w3.org/TR/css3-mediaqueries/#syntax\r\n         */\r\n        /*{ name: \"MEDIA_ONLY\", state: \"media\"},\r\n        { name: \"MEDIA_NOT\", state: \"media\"},\r\n        { name: \"MEDIA_AND\", state: \"media\"},*/\r\n        { name: \"RESOLUTION\", state: \"media\"},\r\n\r\n        /*\r\n         * The following token names are not defined in any CSS specification but are used by the lexer.\r\n         */\r\n\r\n        //not a real token, but useful for stupid IE filters\r\n        { name: \"IE_FUNCTION\" },\r\n\r\n        //part of CSS3 grammar but not the Flex code\r\n        { name: \"CHAR\" },\r\n\r\n        //TODO: Needed?\r\n        //Not defined as tokens, but might as well be\r\n        {\r\n            name: \"PIPE\",\r\n            text: \"|\"\r\n        },\r\n        {\r\n            name: \"SLASH\",\r\n            text: \"/\"\r\n        },\r\n        {\r\n            name: \"MINUS\",\r\n            text: \"-\"\r\n        },\r\n        {\r\n            name: \"STAR\",\r\n            text: \"*\"\r\n        },\r\n\r\n        {\r\n            name: \"LBRACE\",\r\n            text: \"{\"\r\n        },\r\n        {\r\n            name: \"RBRACE\",\r\n            text: \"}\"\r\n        },\r\n        {\r\n            name: \"LBRACKET\",\r\n            text: \"[\"\r\n        },\r\n        {\r\n            name: \"RBRACKET\",\r\n            text: \"]\"\r\n        },\r\n        {\r\n            name: \"EQUALS\",\r\n            text: \"=\"\r\n        },\r\n        {\r\n            name: \"COLON\",\r\n            text: \":\"\r\n        },\r\n        {\r\n            name: \"SEMICOLON\",\r\n            text: \";\"\r\n        },\r\n\r\n        {\r\n            name: \"LPAREN\",\r\n            text: \"(\"\r\n        },\r\n        {\r\n            name: \"RPAREN\",\r\n            text: \")\"\r\n        },\r\n        {\r\n            name: \"DOT\",\r\n            text: \".\"\r\n        }\r\n    ];\r\n\r\n    (function(){\r\n\r\n        var nameMap = [],\r\n            typeMap = {};\r\n\r\n        Tokens.UNKNOWN = -1;\r\n        Tokens.unshift({name:\"EOF\"});\r\n        for (var i=0, len = Tokens.length; i < len; i++){\r\n            nameMap.push(Tokens[i].name);\r\n            Tokens[Tokens[i].name] = i;\r\n            if (Tokens[i].text){\r\n                if (Tokens[i].text instanceof Array){\r\n                    for (var j=0; j < Tokens[i].text.length; j++){\r\n                        typeMap[Tokens[i].text[j]] = i;\r\n                    }\r\n                } else {\r\n                    typeMap[Tokens[i].text] = i;\r\n                }\r\n            }\r\n        }\r\n\r\n        Tokens.name = function(tt){\r\n            return nameMap[tt];\r\n        };\r\n\r\n        Tokens.type = function(c){\r\n            return typeMap[c] || -1;\r\n        };\r\n\r\n    })();\r\n\r\n\r\n\r\n\r\n    //This file will likely change a lot! Very experimental!\r\n    /*global Properties, ValidationTypes, ValidationError, PropertyValueIterator */\r\n    var Validation = {\r\n\r\n        validate: function(property, value){\r\n\r\n            //normalize name\r\n            var name        = property.toString().toLowerCase(),\r\n                parts       = value.parts,\r\n                expression  = new PropertyValueIterator(value),\r\n                spec        = Properties[name],\r\n                part,\r\n                valid,\r\n                j, count,\r\n                msg,\r\n                types,\r\n                last,\r\n                literals,\r\n                max, multi, group;\r\n\r\n            if (!spec) {\r\n                if (name.indexOf(\"-\") !== 0){    //vendor prefixed are ok\r\n                    throw new ValidationError(\"Unknown property '\" + property + \"'.\", property.line, property.col);\r\n                }\r\n            } else if (typeof spec != \"number\"){\r\n\r\n                //initialization\r\n                if (typeof spec == \"string\"){\r\n                    if (spec.indexOf(\"||\") > -1) {\r\n                        this.groupProperty(spec, expression);\r\n                    } else {\r\n                        this.singleProperty(spec, expression, 1);\r\n                    }\r\n\r\n                } else if (spec.multi) {\r\n                    this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);\r\n                } else if (typeof spec == \"function\") {\r\n                    spec(expression);\r\n                }\r\n\r\n            }\r\n\r\n        },\r\n\r\n        singleProperty: function(types, expression, max, partial) {\r\n\r\n            var result      = false,\r\n                value       = expression.value,\r\n                count       = 0,\r\n                part;\r\n\r\n            while (expression.hasNext() && count < max) {\r\n                result = ValidationTypes.isAny(expression, types);\r\n                if (!result) {\r\n                    break;\r\n                }\r\n                count++;\r\n            }\r\n\r\n            if (!result) {\r\n                if (expression.hasNext() && !expression.isFirst()) {\r\n                    part = expression.peek();\r\n                    throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n                } else {\r\n                     throw new ValidationError(\"Expected (\" + types + \") but found '\" + value + \"'.\", value.line, value.col);\r\n                }\r\n            } else if (expression.hasNext()) {\r\n                part = expression.next();\r\n                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n            }\r\n\r\n        },\r\n\r\n        multiProperty: function (types, expression, comma, max) {\r\n\r\n            var result      = false,\r\n                value       = expression.value,\r\n                count       = 0,\r\n                sep         = false,\r\n                part;\r\n\r\n            while(expression.hasNext() && !result && count < max) {\r\n                if (ValidationTypes.isAny(expression, types)) {\r\n                    count++;\r\n                    if (!expression.hasNext()) {\r\n                        result = true;\r\n\r\n                    } else if (comma) {\r\n                        if (expression.peek() == \",\") {\r\n                            part = expression.next();\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    break;\r\n\r\n                }\r\n            }\r\n\r\n            if (!result) {\r\n                if (expression.hasNext() && !expression.isFirst()) {\r\n                    part = expression.peek();\r\n                    throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n                } else {\r\n                    part = expression.previous();\r\n                    if (comma && part == \",\") {\r\n                        throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n                    } else {\r\n                        throw new ValidationError(\"Expected (\" + types + \") but found '\" + value + \"'.\", value.line, value.col);\r\n                    }\r\n                }\r\n\r\n            } else if (expression.hasNext()) {\r\n                part = expression.next();\r\n                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n            }\r\n\r\n        },\r\n\r\n        groupProperty: function (types, expression, comma) {\r\n\r\n            var result      = false,\r\n                value       = expression.value,\r\n                typeCount   = types.split(\"||\").length,\r\n                groups      = { count: 0 },\r\n                partial     = false,\r\n                name,\r\n                part;\r\n\r\n            while(expression.hasNext() && !result) {\r\n                name = ValidationTypes.isAnyOfGroup(expression, types);\r\n                if (name) {\r\n\r\n                    //no dupes\r\n                    if (groups[name]) {\r\n                        break;\r\n                    } else {\r\n                        groups[name] = 1;\r\n                        groups.count++;\r\n                        partial = true;\r\n\r\n                        if (groups.count == typeCount || !expression.hasNext()) {\r\n                            result = true;\r\n                        }\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!result) {\r\n                if (partial && expression.hasNext()) {\r\n                        part = expression.peek();\r\n                        throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n                } else {\r\n                    throw new ValidationError(\"Expected (\" + types + \") but found '\" + value + \"'.\", value.line, value.col);\r\n                }\r\n            } else if (expression.hasNext()) {\r\n                part = expression.next();\r\n                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n            }\r\n        }\r\n\r\n\r\n\r\n    };\r\n    /**\r\n     * Type to use when a validation error occurs.\r\n     * @class ValidationError\r\n     * @namespace parserlib.util\r\n     * @constructor\r\n     * @param {String} message The error message.\r\n     * @param {int} line The line at which the error occurred.\r\n     * @param {int} col The column at which the error occurred.\r\n     */\r\n    function ValidationError(message, line, col){\r\n\r\n        /**\r\n         * The column at which the error occurred.\r\n         * @type int\r\n         * @property col\r\n         */\r\n        this.col = col;\r\n\r\n        /**\r\n         * The line at which the error occurred.\r\n         * @type int\r\n         * @property line\r\n         */\r\n        this.line = line;\r\n\r\n        /**\r\n         * The text representation of the unit.\r\n         * @type String\r\n         * @property text\r\n         */\r\n        this.message = message;\r\n\r\n    }\r\n\r\n    //inherit from Error\r\n    ValidationError.prototype = new Error();\r\n    //This file will likely change a lot! Very experimental!\r\n    /*global Properties, Validation, ValidationError, PropertyValueIterator, console*/\r\n    var ValidationTypes = {\r\n\r\n        isLiteral: function (part, literals) {\r\n            var text = part.text.toString().toLowerCase(),\r\n                args = literals.split(\" | \"),\r\n                i, len, found = false;\r\n\r\n            for (i=0,len=args.length; i < len && !found; i++){\r\n                if (text == args[i].toLowerCase()){\r\n                    found = true;\r\n                }\r\n            }\r\n\r\n            return found;\r\n        },\r\n\r\n        isSimple: function(type) {\r\n            return !!this.simple[type];\r\n        },\r\n\r\n        isComplex: function(type) {\r\n            return !!this.complex[type];\r\n        },\r\n\r\n        /**\r\n         * Determines if the next part(s) of the given expression\r\n         * are any of the given types.\r\n         */\r\n        isAny: function (expression, types) {\r\n            var args = types.split(\" | \"),\r\n                i, len, found = false;\r\n\r\n            for (i=0,len=args.length; i < len && !found && expression.hasNext(); i++){\r\n                found = this.isType(expression, args[i]);\r\n            }\r\n\r\n            return found;\r\n        },\r\n\r\n        /**\r\n         * Determines if the next part(s) of the given expression\r\n         * are one of a group.\r\n         */\r\n        isAnyOfGroup: function(expression, types) {\r\n            var args = types.split(\" || \"),\r\n                i, len, found = false;\r\n\r\n            for (i=0,len=args.length; i < len && !found; i++){\r\n                found = this.isType(expression, args[i]);\r\n            }\r\n\r\n            return found ? args[i-1] : false;\r\n        },\r\n\r\n        /**\r\n         * Determines if the next part(s) of the given expression\r\n         * are of a given type.\r\n         */\r\n        isType: function (expression, type) {\r\n            var part = expression.peek(),\r\n                result = false;\r\n\r\n            if (type.charAt(0) != \"<\") {\r\n                result = this.isLiteral(part, type);\r\n                if (result) {\r\n                    expression.next();\r\n                }\r\n            } else if (this.simple[type]) {\r\n                result = this.simple[type](part);\r\n                if (result) {\r\n                    expression.next();\r\n                }\r\n            } else {\r\n                result = this.complex[type](expression);\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n\r\n\r\n        simple: {\r\n\r\n            \"<absolute-size>\": function(part){\r\n                return ValidationTypes.isLiteral(part, \"xx-small | x-small | small | medium | large | x-large | xx-large\");\r\n            },\r\n\r\n            \"<attachment>\": function(part){\r\n                return ValidationTypes.isLiteral(part, \"scroll | fixed | local\");\r\n            },\r\n\r\n            \"<attr>\": function(part){\r\n                return part.type == \"function\" && part.name == \"attr\";\r\n            },\r\n\r\n            \"<bg-image>\": function(part){\r\n                return this[\"<image>\"](part) || this[\"<gradient>\"](part) ||  part == \"none\";\r\n            },\r\n\r\n            \"<gradient>\": function(part) {\r\n                return part.type == \"function\" && /^(?:\\-(?:ms|moz|o|webkit)\\-)?(?:repeating\\-)?(?:radial\\-|linear\\-)?gradient/i.test(part);\r\n            },\r\n\r\n            \"<box>\": function(part){\r\n                return ValidationTypes.isLiteral(part, \"padding-box | border-box | content-box\");\r\n            },\r\n\r\n            \"<content>\": function(part){\r\n                return part.type == \"function\" && part.name == \"content\";\r\n            },\r\n\r\n            \"<relative-size>\": function(part){\r\n                return ValidationTypes.isLiteral(part, \"smaller | larger\");\r\n            },\r\n\r\n            //any identifier\r\n            \"<ident>\": function(part){\r\n                return part.type == \"identifier\";\r\n            },\r\n\r\n            \"<length>\": function(part){\r\n                if (part.type == \"function\" && /^(?:\\-(?:ms|moz|o|webkit)\\-)?calc/i.test(part)){\r\n                    return true;\r\n                }else{\r\n                    return part.type == \"length\" || part.type == \"number\" || part.type == \"integer\" || part == \"0\";\r\n                }\r\n            },\r\n\r\n            \"<color>\": function(part){\r\n                return part.type == \"color\" || part == \"transparent\";\r\n            },\r\n\r\n            \"<number>\": function(part){\r\n                return part.type == \"number\" || this[\"<integer>\"](part);\r\n            },\r\n\r\n            \"<integer>\": function(part){\r\n                return part.type == \"integer\";\r\n            },\r\n\r\n            \"<line>\": function(part){\r\n                return part.type == \"integer\";\r\n            },\r\n\r\n            \"<angle>\": function(part){\r\n                return part.type == \"angle\";\r\n            },\r\n\r\n            \"<uri>\": function(part){\r\n                return part.type == \"uri\";\r\n            },\r\n\r\n            \"<image>\": function(part){\r\n                return this[\"<uri>\"](part);\r\n            },\r\n\r\n            \"<percentage>\": function(part){\r\n                return part.type == \"percentage\" || part == \"0\";\r\n            },\r\n\r\n            \"<border-width>\": function(part){\r\n                return this[\"<length>\"](part) || ValidationTypes.isLiteral(part, \"thin | medium | thick\");\r\n            },\r\n\r\n            \"<border-style>\": function(part){\r\n                return ValidationTypes.isLiteral(part, \"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset\");\r\n            },\r\n\r\n            \"<margin-width>\": function(part){\r\n                return this[\"<length>\"](part) || this[\"<percentage>\"](part) || ValidationTypes.isLiteral(part, \"auto\");\r\n            },\r\n\r\n            \"<padding-width>\": function(part){\r\n                return this[\"<length>\"](part) || this[\"<percentage>\"](part);\r\n            },\r\n\r\n            \"<shape>\": function(part){\r\n                return part.type == \"function\" && (part.name == \"rect\" || part.name == \"inset-rect\");\r\n            },\r\n\r\n            \"<time>\": function(part) {\r\n                return part.type == \"time\";\r\n            }\r\n        },\r\n\r\n        complex: {\r\n\r\n            \"<bg-position>\": function(expression){\r\n                var types   = this,\r\n                    result  = false,\r\n                    numeric = \"<percentage> | <length>\",\r\n                    xDir    = \"left | right\",\r\n                    yDir    = \"top | bottom\",\r\n                    count = 0,\r\n                    hasNext = function() {\r\n                        return expression.hasNext() && expression.peek() != \",\";\r\n                    };\r\n\r\n                while (expression.peek(count) && expression.peek(count) != \",\") {\r\n                    count++;\r\n                }\r\n\r\n    /*\r\n    <position> = [\r\n      [ left | center | right | top | bottom | <percentage> | <length> ]\r\n    |\r\n      [ left | center | right | <percentage> | <length> ]\r\n      [ top | center | bottom | <percentage> | <length> ]\r\n    |\r\n      [ center | [ left | right ] [ <percentage> | <length> ]? ] &&\r\n      [ center | [ top | bottom ] [ <percentage> | <length> ]? ]\r\n    ]\r\n    */\r\n\r\n                if (count < 3) {\r\n                    if (ValidationTypes.isAny(expression, xDir + \" | center | \" + numeric)) {\r\n                            result = true;\r\n                            ValidationTypes.isAny(expression, yDir + \" | center | \" + numeric);\r\n                    } else if (ValidationTypes.isAny(expression, yDir)) {\r\n                            result = true;\r\n                            ValidationTypes.isAny(expression, xDir + \" | center\");\r\n                    }\r\n                } else {\r\n                    if (ValidationTypes.isAny(expression, xDir)) {\r\n                        if (ValidationTypes.isAny(expression, yDir)) {\r\n                            result = true;\r\n                            ValidationTypes.isAny(expression, numeric);\r\n                        } else if (ValidationTypes.isAny(expression, numeric)) {\r\n                            if (ValidationTypes.isAny(expression, yDir)) {\r\n                                result = true;\r\n                                ValidationTypes.isAny(expression, numeric);\r\n                            } else if (ValidationTypes.isAny(expression, \"center\")) {\r\n                                result = true;\r\n                            }\r\n                        }\r\n                    } else if (ValidationTypes.isAny(expression, yDir)) {\r\n                        if (ValidationTypes.isAny(expression, xDir)) {\r\n                            result = true;\r\n                            ValidationTypes.isAny(expression, numeric);\r\n                        } else if (ValidationTypes.isAny(expression, numeric)) {\r\n                            if (ValidationTypes.isAny(expression, xDir)) {\r\n                                    result = true;\r\n                                    ValidationTypes.isAny(expression, numeric);\r\n                            } else if (ValidationTypes.isAny(expression, \"center\")) {\r\n                                result = true;\r\n                            }\r\n                        }\r\n                    } else if (ValidationTypes.isAny(expression, \"center\")) {\r\n                        if (ValidationTypes.isAny(expression, xDir + \" | \" + yDir)) {\r\n                            result = true;\r\n                            ValidationTypes.isAny(expression, numeric);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return result;\r\n            },\r\n\r\n            \"<bg-size>\": function(expression){\r\n                //<bg-size> = [ <length> | <percentage> | auto ]{1,2} | cover | contain\r\n                var types   = this,\r\n                    result  = false,\r\n                    numeric = \"<percentage> | <length> | auto\",\r\n                    part,\r\n                    i, len;\r\n\r\n                if (ValidationTypes.isAny(expression, \"cover | contain\")) {\r\n                    result = true;\r\n                } else if (ValidationTypes.isAny(expression, numeric)) {\r\n                    result = true;\r\n                    ValidationTypes.isAny(expression, numeric);\r\n                }\r\n\r\n                return result;\r\n            },\r\n\r\n            \"<repeat-style>\": function(expression){\r\n                //repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2}\r\n                var result  = false,\r\n                    values  = \"repeat | space | round | no-repeat\",\r\n                    part;\r\n\r\n                if (expression.hasNext()){\r\n                    part = expression.next();\r\n\r\n                    if (ValidationTypes.isLiteral(part, \"repeat-x | repeat-y\")) {\r\n                        result = true;\r\n                    } else if (ValidationTypes.isLiteral(part, values)) {\r\n                        result = true;\r\n\r\n                        if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {\r\n                            expression.next();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return result;\r\n\r\n            },\r\n\r\n            \"<shadow>\": function(expression) {\r\n                //inset? && [ <length>{2,4} && <color>? ]\r\n                var result  = false,\r\n                    count   = 0,\r\n                    inset   = false,\r\n                    color   = false,\r\n                    part;\r\n\r\n                if (expression.hasNext()) {\r\n\r\n                    if (ValidationTypes.isAny(expression, \"inset\")){\r\n                        inset = true;\r\n                    }\r\n\r\n                    if (ValidationTypes.isAny(expression, \"<color>\")) {\r\n                        color = true;\r\n                    }\r\n\r\n                    while (ValidationTypes.isAny(expression, \"<length>\") && count < 4) {\r\n                        count++;\r\n                    }\r\n\r\n\r\n                    if (expression.hasNext()) {\r\n                        if (!color) {\r\n                            ValidationTypes.isAny(expression, \"<color>\");\r\n                        }\r\n\r\n                        if (!inset) {\r\n                            ValidationTypes.isAny(expression, \"inset\");\r\n                        }\r\n\r\n                    }\r\n\r\n                    result = (count >= 2 && count <= 4);\r\n\r\n                }\r\n\r\n                return result;\r\n            },\r\n\r\n            \"<x-one-radius>\": function(expression) {\r\n                //[ <length> | <percentage> ] [ <length> | <percentage> ]?\r\n                var result  = false,\r\n                    simple = \"<length> | <percentage> | inherit\";\r\n\r\n                if (ValidationTypes.isAny(expression, simple)){\r\n                    result = true;\r\n                    ValidationTypes.isAny(expression, simple);\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n\r\n    parserlib.css = {\r\n        Colors              :Colors,\r\n        Combinator          :Combinator,\r\n        Parser              :Parser,\r\n        PropertyName        :PropertyName,\r\n        PropertyValue       :PropertyValue,\r\n        PropertyValuePart   :PropertyValuePart,\r\n        MediaFeature        :MediaFeature,\r\n        MediaQuery          :MediaQuery,\r\n        Selector            :Selector,\r\n        SelectorPart        :SelectorPart,\r\n        SelectorSubPart     :SelectorSubPart,\r\n        Specificity         :Specificity,\r\n        TokenStream         :TokenStream,\r\n        Tokens              :Tokens,\r\n        ValidationError     :ValidationError\r\n    };\r\n\r\n    return parserlib;\r\n});"]}